<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Database Relationship Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        /* Enhanced Database Relationship Visualization - Complete CSS */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-size: 16px;
        }

        .container {
            max-width: 100vw;
            margin: 0;
            background: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            font-weight: 300;
        }

        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .graph-section {
            flex: 1;
            position: relative;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
        }

        .controls-top {
            background: white;
            padding: 10px 15px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .controls-left,
        .controls-right {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group-inline {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-group-inline label {
            font-size: 0.9em;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
        }

        .control-group-inline select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 140px;
        }

        .graph-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #ffffff 0%, #f8f9fa 100%);
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: white;
            border-left: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
        }

        .sidebar-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .tab-btn {
            flex: 1;
            padding: 10px 14px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.85em;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .tab-btn.active {
            background: white;
            border-bottom-color: #667eea;
            color: #667eea;
            font-weight: 500;
        }

        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 18px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 18px;
        }

        .metric-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .metric-card:hover {
            transform: translateY(-1px);
        }

        .metric-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 3px;
        }

        .metric-label {
            color: #666;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .btn-sm {
            padding: 6px 10px;
            font-size: 0.8em;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
        }

        .section-header {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .compact-control {
            margin-bottom: 8px;
        }

        .compact-control label {
            display: block;
            margin-bottom: 4px;
            font-size: 0.85em;
            font-weight: 500;
            color: #333;
        }

        .compact-control select,
        .compact-control input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .toolbar-btn {
            background: white;
            border: 1px solid #ddd;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .toolbar-btn:hover,
        .toolbar-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            max-width: 220px;
            font-size: 0.8em;
        }

        .legend h4 {
            margin-bottom: 6px;
            color: #333;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            font-size: 0.8em;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .analysis-panel {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 0.85em;
        }

        .analysis-panel h5 {
            color: #333;
            margin-bottom: 6px;
            font-size: 0.85em;
        }

        .status-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 4px;
        }

        .status-good {
            background: #28a745;
        }

        .status-warning {
            background: #ffc107;
        }

        .status-error {
            background: #dc3545;
        }

        /* Enhanced relationship details styling */
        .relationship-card {
            background: white;
            border-radius: 8px;
            padding: 20px; /* Increased from 12px */
            margin-bottom: 15px; /* Increased from 10px */
            border-left: 4px solid #667eea; /* Slightly thicker border */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); /* Enhanced shadow */
            font-size: 0.9em; /* Increased from 0.85em */
            line-height: 1.5; /* Better line spacing */
        }

        .relationship-card h4 {
            font-size: 1.3em; /* Larger title */
            margin-bottom: 15px; /* More space after title */
            color: #2d3748;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
        }

        .relationship-card h5 {
            font-size: 1.1em; /* Larger section headers */
            margin-top: 20px; /* More space before sections */
            margin-bottom: 12px;
            color: #4a5568;
            font-weight: 600;
        }

        .relationship-info {
            background: #f7fafc;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 3px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .relationship-info:hover {
            background: #edf2f7;
            border-left-color: #667eea;
        }

        .relationship-info strong {
            color: #2d3748;
            font-size: 1em;
        }

        .relationship-info small {
            color: #718096;
            font-size: 0.85em;
            margin-top: 4px;
            display: block;
        }

        .relationship-strength {
            display: inline-block;
            padding: 3px 8px; /* Increased padding */
            border-radius: 12px; /* More rounded */
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
            margin-top: 5px;
        }

        .path-finder {
            background: #e3f2fd;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 0.85em;
        }

        .join-preview {
            background: #f5f5f5;
            border-radius: 4px;
            padding: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.7em;
            margin-top: 6px;
            max-height: 100px;
            overflow-y: auto;
        }

        .query-builder {
            background: #fff;
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            border: 1px solid #e9ecef;
            font-size: 0.85em;
        }

        .query-output {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.7em;
            margin-top: 6px;
            max-height: 80px;
            overflow-y: auto;
        }

        .export-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin-top: 8px;
        }

        .export-btn {
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 0.75em;
            text-align: center;
            transition: all 0.2s ease;
        }

        .export-btn:hover {
            background: #f8f9fa;
            border-color: #667eea;
        }

        /* Enhanced node styling with opacity */
        .node {
            cursor: pointer;
            stroke-width: 2px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            fill-opacity: 0.4; /* Set node opacity to 0.4 */
        }

        .node:hover {
            stroke-width: 3px;
            filter: drop-shadow(0 4px 12px rgba(102, 126, 234, 0.4));
            transform: scale(1.05);
            fill-opacity: 0.7; /* Increase opacity on hover */
        }

        .node.selected {
            stroke: #ff6b6b;
            stroke-width: 4px;
            filter: drop-shadow(0 0 12px rgba(255, 107, 107, 0.8));
            fill-opacity: 0.8; /* Higher opacity when selected */
        }

        .node.highlighted {
            stroke: #ffd700;
            stroke-width: 3px;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));
            animation: pulse-glow 2s ease-in-out infinite alternate;
            fill-opacity: 0.6;
        }

        /* Special effect for nodes with one-to-many relationships */
        .node.one-to-many {
            animation: one-to-many-pulse 3s ease-in-out infinite;
            stroke: #ff6b6b;
            stroke-width: 3px;
        }

        /* One-to-many transitional animation */
        @keyframes one-to-many-pulse {
            0% {
                fill-opacity: 0.3;
                stroke-opacity: 0.6;
                transform: scale(1);
                filter: drop-shadow(0 0 5px rgba(255, 107, 107, 0.3));
            }
            25% {
                fill-opacity: 0.5;
                stroke-opacity: 0.8;
                transform: scale(1.03);
                filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.5));
            }
            50% {
                fill-opacity: 0.7;
                stroke-opacity: 1;
                transform: scale(1.06);
                filter: drop-shadow(0 0 15px rgba(255, 107, 107, 0.7));
            }
            75% {
                fill-opacity: 0.5;
                stroke-opacity: 0.8;
                transform: scale(1.03);
                filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.5));
            }
            100% {
                fill-opacity: 0.3;
                stroke-opacity: 0.6;
                transform: scale(1);
                filter: drop-shadow(0 0 5px rgba(255, 107, 107, 0.3));
            }
        }

        /* Enhanced node category styling with gradients */
        .node-entity {
            fill: url(#entityGradient);
            stroke: #5a67d8;
        }

        .node-transaction {
            fill: url(#transactionGradient);
            stroke: #38a169;
        }

        .node-lookup {
            fill: url(#lookupGradient);
            stroke: #dd6b20;
        }

        .node-data {
            fill: url(#dataGradient);
            stroke: #3182ce;
        }

        /* Enhanced link styling with importance-based colors */
        .link {
            stroke-opacity: 0.8;
            stroke-width: 1.5px;
            fill: none;
            stroke-dasharray: 3, 2;
            transition: all 0.3s ease;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        .link:hover {
            stroke-width: 2.5px;
            stroke-opacity: 1;
            stroke-dasharray: 4, 1;
            filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.3));
        }

        .link.selected {
            stroke-width: 3px;
            stroke-opacity: 1;
            stroke-dasharray: 4, 1;
        }

        .link.highlighted {
            stroke-width: 2.5px;
            stroke-opacity: 1;
            stroke-dasharray: 4, 1;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
            animation: link-pulse 2s ease-in-out infinite alternate;
        }

        /* Enhanced relationship strength indicators with importance colors */
        .link-strength-high {
            stroke-width: 2px;
            stroke-opacity: 0.9;
        }

        .link-strength-medium {
            stroke-width: 1.5px;
            stroke-opacity: 0.8;
        }

        .link-strength-low {
            stroke-width: 1px;
            stroke-opacity: 0.7;
            stroke-dasharray: 2, 3;
        }

        .link-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 9px;
            fill: #666;
            text-anchor: middle;
            pointer-events: none;
        }

        /* Enhanced tooltip */
        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(30, 30, 30, 0.95) 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.8em;
            pointer-events: none;
            z-index: 1000;
            max-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(102, 126, 234, 0.3);
            backdrop-filter: blur(10px);
        }

        .tooltip .tooltip-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 6px;
            margin-bottom: 8px;
            font-weight: bold;
            color: #667eea;
        }

        .tooltip .tooltip-section {
            margin-bottom: 8px;
        }

        .tooltip .tooltip-label {
            color: #a0a0a0;
            font-size: 0.85em;
            font-weight: 500;
        }

        .tooltip .tooltip-value {
            color: #ffffff;
            font-weight: 400;
            line-height: 1.4;
            margin-top: 2px;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
        }

        /* Loading indicator */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 300px;
            flex-direction: column;
            color: #666;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        /* Activity indicators for nodes */
        .node-activity-ring {
            fill: none;
            stroke: #00ff88;
            stroke-width: 2px;
            stroke-opacity: 0;
            animation: activity-pulse 1.5s ease-in-out infinite;
        }

        /* Hide organelles */
        .node-organelle {
            display: none;
        }

        /* Enhanced node labels */
        .node-label {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            fill: #2d3748;
            paint-order: stroke;
            stroke: white;
            stroke-width: 4px;
            stroke-linejoin: round;
        }

        /* Relationship visualization styles */
        .relationship-strength {
            display: inline-block;
            padding: 1px 4px;
            border-radius: 8px;
            font-size: 0.65em;
            font-weight: bold;
            margin-left: 6px;
        }

        .strength-high {
            background: #d4edda;
            color: #155724;
        }

        .strength-medium {
            background: #fff3cd;
            color: #856404;
        }

        .strength-low {
            background: #f8d7da;
            color: #721c24;
        }

        /* Enhanced metrics display */
        .analysis-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px; /* Increased gap */
            margin: 15px 0; /* More margin */
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .metric-item {
            background: white;
            padding: 12px; /* Increased padding */
            border-radius: 6px;
            text-align: center;
            font-size: 0.85em;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .metric-item:hover {
            transform: translateY(-2px);
        }

        .metric-item .value {
            font-size: 1.4em; /* Larger values */
            font-weight: bold;
            color: #667eea;
            margin-bottom: 4px;
        }

        .metric-item .label {
            font-size: 0.8em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced button styling */
        .relationship-card .btn {
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 0.85em;
            padding: 8px 15px;
        }

        /* Table info section */
        .table-info-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .table-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            font-size: 0.75em;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 1em;
            font-weight: 600;
            color: #2d3748;
        }


        /* Scrollable area improvements */
        #relationshipDetails {
            max-height: none; /* Remove height restriction */
            overflow-y: visible; /* Remove scroll for now */
            padding: 0;
        }

        .scrollable {
            max-height: 600px; /* Increased from 500px */
            overflow-y: auto;
            padding-right: 8px; /* Space for scrollbar */
        }

        /* Custom scrollbar */
        .scrollable::-webkit-scrollbar {
            width: 6px;
        }

        .scrollable::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .scrollable::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .scrollable::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .mini-section {
            margin-bottom: 10px;
        }

        .mini-section:last-child {
            margin-bottom: 0;
        }

        /* Animations */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse-glow {
            0% {
                filter: drop-shadow(0 0 8px rgba(102, 126, 234, 0.6));
                transform: scale(1);
            }
            100% {
                filter: drop-shadow(0 0 16px rgba(102, 126, 234, 1));
                transform: scale(1.02);
            }
        }

        @keyframes link-pulse {
            0% {
                stroke-opacity: 0.8;
            }
            100% {
                stroke-opacity: 1;
            }
        }

        @keyframes activity-pulse {
            0% {
                stroke-opacity: 0;
                transform: scale(1);
            }
            50% {
                stroke-opacity: 0.8;
                transform: scale(1.1);
            }
            100% {
                stroke-opacity: 0;
                transform: scale(1.2);
            }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .sidebar {
                width: 280px;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
                gap: 4px;
            }

            .legend {
                max-width: 180px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: 300px;
            }

            .controls-top {
                flex-direction: column;
                align-items: stretch;
            }

            .controls-left,
            .controls-right {
                justify-content: center;
            }

            .legend {
                position: relative;
                bottom: auto;
                left: auto;
                margin: 10px;
                max-width: none;
            }

            /* New node types */
            .node-view {
                fill: url(#viewGradient);
                stroke: #8b5cf6;
            }

            .node-index {
                fill: url(#indexGradient);
                stroke: #f59e0b;
            }

            .node-trigger {
                fill: url(#triggerGradient);
                stroke: #ef4444;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>🔗 Enhanced Database Relationship Explorer</h1>
        <p>Interactive visualization and analysis of database relationships with AI-powered insights</p>
    </div>

    <div class="main-content">
        <div class="graph-section">
            <!-- Top Controls Bar -->
            <div class="controls-top">
                <div class="controls-left">
                    <div class="control-group-inline">
                        <label>Layout:</label>
                        <select id="layoutSelect" onchange="setLayoutMode(this.value)">
                            <option value="force">🌐 Force</option>
                            <option value="hierarchical">🏗️ Hierarchical</option>
                            <option value="circular">⭕ Circular</option>
                            <option value="matrix">📊 Matrix</option>
                        </select>
                    </div>

                    <div class="control-group-inline">
                        <label>Node Size:</label>
                        <select id="nodeSizeMode" onchange="updateNodeSizing()">
                            <option value="rows">Row Count</option>
                            <option value="columns">Column Count</option>
                            <option value="relationships">Relationships</option>
                            <option value="importance">Importance</option>
                            <option value="uniform">Uniform</option>
                        </select>
                    </div>

                    <div class="control-group-inline">
                        <label>Edge Labels:</label>
                        <select id="edgeLabelMode" onchange="updateEdgeLabels()">
                            <option value="none">None</option>
                            <option value="columns">Columns</option>
                            <option value="type">Type</option>
                            <option value="strength">Strength</option>
                        </select>
                    </div>

                    <div class="control-group-inline">
                        <label>Highlight:</label>
                        <select id="highlightMode" onchange="updateHighlighting()">
                            <option value="none">None</option>
                            <option value="connected">Connected</option>
                            <option value="orphaned">Orphaned</option>
                            <option value="central">Central</option>
                        </select>
                    </div>
                </div>

                <div class="controls-right">
                    <button class="toolbar-btn" onclick="zoomToFit()" title="Zoom to Fit">
                        🔍 Fit
                    </button>
                    <button class="toolbar-btn" onclick="toggleAnimation()" title="Toggle Animation">
                        ⚡ Animate
                    </button>
                    <button class="toolbar-btn" onclick="exportDiagram()" title="Export">
                        💾 Export
                    </button>
                    <button class="toolbar-btn" onclick="showFullScreen()" title="Full Screen">
                        🖥️ Full
                    </button>
                    <button class="toolbar-btn" onclick="resetLayout()" title="Reset Layout">
                        🔄 Reset
                    </button>
                </div>
            </div>

            <!-- Graph Container -->
            <div class="graph-container" id="graphContainer">
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <div>Loading enhanced relationship data...</div>
                </div>
            </div>

            <!-- Legend -->
            <div class="legend" id="graphLegend">
                <h4>📋 Legend</h4>
                <div class="legend-item">
                    <div class="legend-color node-entity"></div>
                    <span>Tables</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-view"></div>
                    <span>Views</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-index"></div>
                    <span>Indexes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-trigger"></div>
                    <span>Triggers</span>
                </div>

                <h4 style="margin-top: 10px;">🔗 Relationship Importance</h4>
                <div class="legend-item">
                    <div style="width: 15px; height: 2px; background: #dc3545; margin-right: 6px;"></div>
                    <span style="font-size: 0.7em;">Low</span>
                </div>
                <div class="legend-item">
                    <div style="width: 15px; height: 2px; background: #ffc107; margin-right: 6px;"></div>
                    <span style="font-size: 0.7em;">Medium</span>
                </div>
                <div class="legend-item">
                    <div style="width: 15px; height: 2px; background: #28a745; margin-right: 6px;"></div>
                    <span style="font-size: 0.7em;">High</span>
                </div>
                <div class="legend-item">
                    <div style="width: 15px; height: 2px; background: #007bff; margin-right: 6px;"></div>
                    <span style="font-size: 0.7em;">Very High</span>
                </div>
                <div class="legend-item">
                    <div style="width: 15px; height: 2px; background: #6f42c1; margin-right: 6px;"></div>
                    <span style="font-size: 0.7em;">Critical</span>
                </div>
            </div>
        </div>

        <!-- Sidebar with Tabs -->
        <div class="sidebar">
            <div class="sidebar-tabs">
                <button class="tab-btn active" onclick="switchTab('metrics')">📊 Metrics</button>
                <button class="tab-btn" onclick="switchTab('analysis')">🔍 Analysis</button>
                <button class="tab-btn" onclick="switchTab('tools')">🛠️ Tools</button>
                <button class="tab-btn" onclick="switchTab('details')">📋 Details</button>
            </div>

            <div class="tab-content">
                <!-- Metrics Tab -->
                <div id="metrics-tab" class="tab-panel active">
                    <div class="section-header">📊 Database Metrics</div>
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-value" id="totalTables">0</div>
                            <div class="metric-label">Tables</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="totalRelationships">0</div>
                            <div class="metric-label">Relationships</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="connectivityRatio">0%</div>
                            <div class="metric-label">Connected</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="complexityScore">0</div>
                            <div class="metric-label">Complexity</div>
                        </div>
                    </div>

                    <div class="section-header">🏥 Health Status</div>
                    <div class="analysis-panel">
                        <div id="healthStatus">
                            <span class="status-indicator status-good"></span>
                            <span>Analyzing...</span>
                        </div>
                        <div class="analysis-metrics" id="healthMetrics">
                            <div class="metric-item">
                                <div class="value" id="integrityScore">-</div>
                                <div class="label">Integrity</div>
                            </div>
                            <div class="metric-item">
                                <div class="value" id="orphanedCount">-</div>
                                <div class="label">Orphaned</div>
                            </div>
                        </div>
                    </div>

                    <div class="section-header">⚡ Quick Actions</div>
                    <div class="btn-group">
                        <button class="btn btn-sm" onclick="refreshRelationshipData()">
                            🔄 Refresh
                        </button>
                        <button class="btn btn-secondary btn-sm" onclick="runIntegrityAnalysis()">
                            🛡️ Check
                        </button>
                        <button class="btn btn-warning btn-sm" onclick="suggestOptimizations()">
                            💡 Tips
                        </button>
                        <button class="btn btn-success btn-sm" onclick="generateEnhancedReport()">
                            📊 Report
                        </button>
                    </div>
                </div>

                <!-- Analysis Tab -->
                <div id="analysis-tab" class="tab-panel">
                    <div class="section-header">🤖 AI Insights</div>
                    <div class="analysis-panel scrollable" id="aiInsights">
                        <div>Loading AI analysis...</div>
                    </div>
                    <button class="btn btn-warning btn-sm" onclick="generateAIInsights()">
                        🤖 Refresh Analysis
                    </button>

                    <div class="section-header">🛤️ Path Finder</div>
                    <div class="path-finder">
                        <div class="compact-control">
                            <label>From Table:</label>
                            <select id="pathFromTable">
                                <option value="">Select table...</option>
                            </select>
                        </div>
                        <div class="compact-control">
                            <label>To Table:</label>
                            <select id="pathToTable">
                                <option value="">Select table...</option>
                            </select>
                        </div>
                        <button class="btn btn-success btn-sm" onclick="findOptimalPath()">
                            🔍 Find Path
                        </button>
                        <div class="join-preview" id="joinPreview" style="display: none;"></div>
                    </div>

                    <div class="section-header">🔧 Query Builder</div>
                    <div class="query-builder">
                        <div class="compact-control">
                            <label>Query Type:</label>
                            <select id="queryType" onchange="updateQueryBuilder()">
                                <option value="join">JOIN Query</option>
                                <option value="aggregate">Aggregate</option>
                                <option value="integrity">Integrity</option>
                                <option value="optimization">Optimization</option>
                            </select>
                        </div>
                        <button class="btn btn-sm" onclick="generateSmartQuery()">
                            ⚡ Generate
                        </button>
                        <div class="query-output" id="generatedQuery" style="display: none;"></div>
                    </div>
                </div>

                <!-- Tools Tab -->
                <div id="tools-tab" class="tab-panel">
                    <div class="section-header">📋 Templates & Stats</div>
                    <div class="btn-group">
                        <button class="btn btn-info btn-sm" onclick="generateQueryTemplates()">
                            📋 Templates
                        </button>
                        <button class="btn btn-primary btn-sm" onclick="showSchemaStatistics()">
                            📊 Statistics
                        </button>
                    </div>

                    <div class="section-header">🔧 Maintenance</div>
                    <div class="btn-group">
                        <button class="btn btn-success btn-sm" onclick="runVacuum()">
                            🗜️ VACUUM
                        </button>
                        <button class="btn btn-info btn-sm" onclick="runAnalyze()">
                            📊 ANALYZE
                        </button>
                    </div>

                    <div class="section-header">🔗 Suggestions</div>
                    <button class="btn btn-success btn-sm" onclick="loadRelationshipSuggestions()">
                        🔗 Load Suggestions
                    </button>

                    <div class="section-header">💾 Export Options</div>
                    <div class="export-grid">
                        <button class="export-btn" onclick="exportAsJSON()">
                            📄 JSON
                        </button>
                        <button class="export-btn" onclick="exportAsGraphML()">
                            🔗 GraphML
                        </button>
                        <button class="export-btn" onclick="exportAsCytoscape()">
                            🌐 Cytoscape
                        </button>
                        <button class="export-btn" onclick="exportAsDOT()">
                            📊 DOT
                        </button>
                    </div>

                    <div class="section-header">🎛️ Filters</div>
                    <div class="compact-control">
                        <label>Category Filter:</label>
                        <select id="categoryFilter" onchange="filterByCategory()">
                            <option value="all">All Objects</option>
                            <option value="entity">Tables</option>
                            <option value="view">Views</option>
                            <option value="index">Indexes</option>
                            <option value="trigger">Triggers</option>
                            <option value="transaction">Transaction Tables</option>
                            <option value="lookup">Lookup Tables</option>
                            <option value="data">Data Tables</option>
                        </select>
                    </div>
                </div>

                <!-- Details Tab -->
                <div id="details-tab" class="tab-panel">
                    <div class="section-header">🔗 Relationship Details</div>
                    <div id="relationshipDetails" class="scrollable">
                        <div style="color: #666; font-style: italic; font-size: 1.1em; text-align: center; padding: 40px; background: #f8f9fa; border-radius: 8px; border: 2px dashed #dee2e6;">
                            <div style="font-size: 3em; margin-bottom: 15px; opacity: 0.5;">🔍</div>
                            <div style="font-weight: 500; margin-bottom: 8px;">No Selection</div>
                            <div style="font-size: 0.9em; opacity: 0.8;">Click on a node or relationship to see detailed information</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Tooltip -->
<div class="tooltip" id="tooltip" style="display: none;"></div>

<script>
    // Enhanced Global Variables
    let enhancedGraphData = null;
    let enhancedSimulation = null;
    let enhancedSvg = null;
    let currentLayout = 'force';
    let selectedNode = null;
    let selectedLink = null;
    let animationEnabled = true;
    let relationshipMetrics = null;
    let joinPaths = new Map();
    let currentTab = 'metrics';

    // Enhanced API endpoints
    const API_ENDPOINTS = {
        relationshipGraph: '/api/schema/relationship-graph',
        relationshipAnalysis: '/api/schema/relationship-analysis',
        joinPaths: '/api/schema/join-paths',
        relationshipSuggestions: '/api/schema/relationship-suggestions',
        relationshipMetrics: '/api/schema/relationship-metrics',
        exportDiagram: '/api/schema/export-relationship-diagram'
    };

    // Tab switching functionality
    function switchTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');

        // Update tab panels
        document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
        document.getElementById(tabName + '-tab').classList.add('active');

        currentTab = tabName;
    }

    // Enhanced initialization
    document.addEventListener('DOMContentLoaded', function () {
        console.log('🚀 Initializing Enhanced Relationship Visualization');

        try {
            initializeEnhancedGraph();
            showInitialContent();
            loadEnhancedRelationshipData();
        } catch (error) {
            console.error('❌ Failed to initialize relationship visualization:', error);
            showMessage('❌ Failed to initialize visualization: ' + error.message, 'error');
            showFallbackInterface();
        }
    });

    // Show initial loading content
    function showInitialContent() {
        // Update metrics with placeholder values
        document.getElementById('totalTables').textContent = '...';
        document.getElementById('totalRelationships').textContent = '...';
        document.getElementById('connectivityRatio').textContent = '...';
        document.getElementById('complexityScore').textContent = '...';

        // Show loading message in insights
        const insightsEl = document.getElementById('aiInsights');
        if (insightsEl) {
            insightsEl.innerHTML = '<div style="color: #667eea;">🔄 Loading relationship insights...</div>';
        }
    }

    // Show fallback interface when things fail
    function showFallbackInterface() {
        const container = document.querySelector('.graph-container');
        if (container) {
            container.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center; padding: 40px;">
                <div style="font-size: 64px; margin-bottom: 20px;">🔗</div>
                <h3>Database Relationship Visualization</h3>
                <p style="color: #666; max-width: 500px; margin: 20px 0;">
                    This tool visualizes the relationships between tables in your database.
                    To get started, please connect to a database from the main interface.
                </p>
                <div style="margin-top: 30px;">
                    <a href="/static" style="padding: 12px 24px; background: #667eea; color: white; text-decoration: none; border-radius: 8px; margin-right: 10px;">
                        📊 Go to Database Explorer
                    </a>
                    <a href="/api/docs" style="padding: 12px 24px; background: #f8f9fa; color: #333; text-decoration: none; border-radius: 8px; border: 1px solid #ddd;">
                        📚 View API Documentation
                    </a>
                </div>
            </div>
        `;
        }

        // Update panels with helpful info
        const insightsEl = document.getElementById('aiInsights');
        if (insightsEl) {
            insightsEl.innerHTML = `
            <div style="text-align: center; padding: 20px;">
                <h4>💡 How to Use</h4>
                <ol style="text-align: left; max-width: 300px; margin: 0 auto;">
                    <li>Go to the <a href="/static">main page</a></li>
                    <li>Upload a SQLite database file</li>
                    <li>Return here to view relationships</li>
                </ol>
            </div>
        `;
        }
    }

    // Enhanced graph initialization with all node types and improved arrows
    function initializeEnhancedGraph() {
        const container = d3.select('#graphContainer');
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;

        container.selectAll('*').remove();

        enhancedSvg = container.append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('background', 'radial-gradient(circle at center, #ffffff 0%, #f8f9fa 100%)');

        // Enhanced definitions with gradients and patterns
        const defs = enhancedSvg.append('defs');

        // Gradient definitions for different node types
        const entityGradient = defs.append('linearGradient')
            .attr('id', 'entityGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        entityGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#667eea')
            .attr('stop-opacity', 1);
        entityGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#764ba2')
            .attr('stop-opacity', 1);

        const transactionGradient = defs.append('linearGradient')
            .attr('id', 'transactionGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        transactionGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#48bb78')
            .attr('stop-opacity', 1);
        transactionGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#38a169')
            .attr('stop-opacity', 1);

        const lookupGradient = defs.append('linearGradient')
            .attr('id', 'lookupGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        lookupGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#ed8936')
            .attr('stop-opacity', 1);
        lookupGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#dd6b20')
            .attr('stop-opacity', 1);

        const dataGradient = defs.append('linearGradient')
            .attr('id', 'dataGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        dataGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#4299e1')
            .attr('stop-opacity', 1);
        dataGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#3182ce')
            .attr('stop-opacity', 1);

        // Add new gradients for views, indexes, triggers
        const viewGradient = defs.append('linearGradient')
            .attr('id', 'viewGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        viewGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#8b5cf6')
            .attr('stop-opacity', 1);
        viewGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#7c3aed')
            .attr('stop-opacity', 1);

        const indexGradient = defs.append('linearGradient')
            .attr('id', 'indexGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        indexGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#f59e0b')
            .attr('stop-opacity', 1);
        indexGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#d97706')
            .attr('stop-opacity', 1);

        const triggerGradient = defs.append('linearGradient')
            .attr('id', 'triggerGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        triggerGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#ef4444')
            .attr('stop-opacity', 1);
        triggerGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#dc2626')
            .attr('stop-opacity', 1);

        // Enhanced arrow markers with better visibility for dashed lines
        defs.append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 9)  // Position closer to node edge
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .attr('markerUnits', 'strokeWidth')  // Scale with stroke width
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#999')
            .attr('stroke', '#999')
            .attr('stroke-width', 1);

        defs.append('marker')
            .attr('id', 'arrowhead-highlighted')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 9)
            .attr('refY', 0)
            .attr('markerWidth', 8)
            .attr('markerHeight', 8)
            .attr('orient', 'auto')
            .attr('markerUnits', 'strokeWidth')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#ffd700')
            .attr('stroke', '#ffd700')
            .attr('stroke-width', 1);

        // Add importance-based arrow markers with better visibility
        const importanceColors = ['#dc3545', '#ffc107', '#28a745', '#007bff', '#6f42c1'];
        importanceColors.forEach((color, index) => {
            defs.append('marker')
                .attr('id', `arrowhead-importance-${index}`)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 9)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .attr('markerUnits', 'strokeWidth')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', color)
                .attr('stroke', color)
                .attr('stroke-width', 1);
        });

        // Enhanced zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', function (event) {
                enhancedSvg.select('.graph-group').attr('transform', event.transform);
            });

        enhancedSvg.call(zoom);
        enhancedSvg.append('g').attr('class', 'graph-group');

        console.log('✅ Enhanced graph initialized with gradients, effects, and all database object types');
    }

    // Function to calculate link importance based on connected nodes
    // Function to calculate link importance based on connected nodes
    function calculateLinkImportance(edge) {
        if (!enhancedGraphData || !enhancedGraphData.graph) return 0;

        const sourceNode = enhancedGraphData.graph.nodes.find(n =>
            (n.id || n.name) === (edge.source.id || edge.source.name || edge.source)
        );
        const targetNode = enhancedGraphData.graph.nodes.find(n =>
            (n.id || n.name) === (edge.target.id || edge.target.name || edge.target)
        );

        const sourceImportance = sourceNode ? (sourceNode.importance || 0) : 0;
        const targetImportance = targetNode ? (targetNode.importance || 0) : 0;
        const avgImportance = (sourceImportance + targetImportance) / 2;

        // Normalize to 0-4 scale for color selection
        if (avgImportance > 10000) return 4;
        if (avgImportance > 5000) return 3;
        if (avgImportance > 1000) return 2;
        if (avgImportance > 100) return 1;
        return 0;
    }

    // Function to get link color based on importance
    function getLinkColor(edge) {
        const importance = calculateLinkImportance(edge);
        const colors = ['#dc3545', '#ffc107', '#28a745', '#007bff', '#6f42c1'];
        return colors[importance];
    }

    // Function to identify and apply one-to-many relationship effects
    function applyOneToManyEffects() {
        if (!enhancedGraphData || !enhancedGraphData.graph) return;

        const {nodes, edges} = enhancedGraphData.graph;

        // Identify nodes with one-to-many relationships
        const oneToManyNodes = new Set();

        edges.forEach(edge => {
            if (edge.relationship_type === 'one_to_many') {
                oneToManyNodes.add(edge.source.id || edge.source.name || edge.source);
            }
        });

        // Apply special styling to one-to-many nodes
        enhancedSvg.selectAll('.node')
            .classed('one-to-many', d => oneToManyNodes.has(d.id || d.name));

        console.log(`✨ Applied one-to-many effects to ${oneToManyNodes.size} nodes`);
    }

    // Enhanced data loading with comprehensive analysis
    async function loadEnhancedRelationshipData() {
        try {
            console.log('📡 Loading enhanced relationship data...');
            showLoading(true);

            // Check if we're connected to a database first
            const statusResponse = await fetch('/api/status');
            const statusData = await statusResponse.json();

            if (!statusData.connected_database) {
                throw new Error('No database connected. Please upload a database file first.');
            }

            // Load comprehensive relationship data - make each API call resilient
            // Load comprehensive relationship data including all database objects
            const promises = [
                fetch(API_ENDPOINTS.relationshipGraph + '?include_all=true').then(r => r.json()).catch(e => ({
                    success: false,
                    error: 'Graph endpoint failed'
                })),
                fetch(API_ENDPOINTS.relationshipAnalysis).then(r => r.json()).catch(e => ({
                    success: false,
                    error: 'Analysis endpoint failed'
                })),
                fetch(API_ENDPOINTS.relationshipMetrics).then(r => r.json()).catch(e => ({
                    success: false,
                    error: 'Metrics endpoint failed'
                }))
            ];

            // Try to load suggestions but don't fail if it doesn't work
            try {
                promises.push(fetch(API_ENDPOINTS.relationshipSuggestions).then(r => r.json()).catch(e => ({
                    success: false,
                    error: 'Suggestions endpoint failed'
                })));
            } catch (e) {
                console.warn('Suggestions endpoint not available:', e);
                promises.push(Promise.resolve({success: false, error: 'Suggestions not available'}));
            }

            const results = await Promise.all(promises);
            const [graphData, analysisData, metricsData, suggestionsData] = results;

            console.log('🔍 API Response status:', {
                graph: graphData.success,
                analysis: analysisData.success,
                metrics: metricsData.success,
                suggestions: suggestionsData?.success
            });

            if (!graphData.success) {
                throw new Error(graphData.error || 'Failed to load relationship graph');
            }

            // *** ALWAYS enrich node data with column information ***
            console.log('📊 Original graph data sample:', {
                nodeCount: graphData.graph?.nodes?.length || 0,
                edgeCount: graphData.graph?.edges?.length || 0,
                sampleNode: graphData.graph?.nodes?.[0] || null
            });

            // ALWAYS call enrichment - don't check if data is missing
            if (graphData.success && graphData.graph.nodes.length > 0) {
                console.log('🔄 Enriching ALL nodes with table structure data...');
                await enrichNodeDataWithSchema(graphData.graph.nodes);

                // Log after enrichment
                console.log('📊 Enriched graph data sample:', {
                    sampleNode: graphData.graph?.nodes?.[0] || null
                });
            }

            enhancedGraphData = graphData;
            relationshipMetrics = metricsData.success ? metricsData.metrics : null;

            // Update enhanced metrics
            updateEnhancedMetrics(graphData.graph.metrics, relationshipMetrics);

            // Populate enhanced table selectors
            populateEnhancedTableSelectors(graphData.graph.nodes);

            // Load and display analysis insights with fallback
            if (analysisData.success) {
                updateAnalysisInsights(analysisData.analysis, analysisData.summary);
            } else {
                console.warn('Analysis data not available:', analysisData.error);
                const insightsEl = document.getElementById('aiInsights');
                if (insightsEl) {
                    insightsEl.innerHTML = '<div style="color: #666;">⚠️ Analysis data not available</div>';
                }
            }

            // Load relationship suggestions - make this optional
            if (suggestionsData && suggestionsData.success) {
                updateRelationshipSuggestions(suggestionsData.suggestions);
            } else {
                console.warn('Suggestions data not available:', suggestionsData?.error);
            }

            // Render the enhanced graph
            renderEnhancedGraph(graphData.graph);

            // Generate initial AI insights
            setTimeout(() => generateAIInsights(), 2000);

            showLoading(false);
            showMessage('✅ Enhanced relationship data loaded successfully', 'success');

        } catch (error) {
            console.error('❌ Error loading enhanced relationship data:', error);
            showLoading(false);

            // Show more helpful error message
            if (error.message.includes('No database connected')) {
                showMessage('❌ No database connected. Please go to the main page and upload a database file first.', 'error');

                // Add a link to go back to main page
                setTimeout(() => {
                    const container = document.querySelector('.graph-container');
                    if (container) {
                        container.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center;">
                        <h3>🔌 No Database Connected</h3>
                        <p>Please connect to a database first to view relationships.</p>
                        <a href="/static" style="padding: 10px 20px; background: #667eea; color: white; text-decoration: none; border-radius: 6px; margin-top: 20px;">
                            📊 Go to Main Database Explorer
                        </a>
                    </div>
                `;
                    }
                }, 1000);
            } else {
                showMessage('❌ Error loading relationship data: ' + error.message, 'error');
            }
        }
    }

    // Function to get all database objects (tables, views, indexes, triggers)
    async function getAllDatabaseObjects() {
        try {
            const response = await fetch('/api/execute-query', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    query: `
                SELECT
                    name,
                    type,
                    tbl_name as parent_table,
                    sql
                FROM sqlite_master
                WHERE type IN ('table', 'view', 'index', 'trigger')
                    AND name NOT LIKE 'sqlite_%'
                ORDER BY type, name;
                `
                })
            });

            const result = await response.json();
            if (result.success) {
                return result.data || [];
            }
            return [];
        } catch (error) {
            console.error('Error fetching database objects:', error);
            return [];
        }
    }

    // 3. ALTERNATIVE: If the above doesn't work, add this manual column detection function
    async function detectColumnCounts(nodes) {
        console.log('🔍 Manually detecting column counts...');

        try {
            // Try to execute PRAGMA table_info for each table
            const promises = nodes.map(async (node) => {
                const tableName = node.name || node.id;
                try {
                    const response = await fetch('/api/execute-query', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            query: `PRAGMA table_info(\`${tableName}\`);`
                        })
                    });

                    const result = await response.json();
                    if (result.success && result.data) {
                        const columnCount = result.data.length;
                        node.column_count = node.column_count || columnCount;
                        node.columns = node.columns || columnCount;
                        console.log(`✅ Detected ${columnCount} columns for ${tableName}`);
                    }
                } catch (error) {
                    console.warn(`⚠️ Could not detect columns for ${tableName}:`, error);
                }
            });

            await Promise.all(promises);
            console.log('🎉 Column detection completed');
        } catch (error) {
            console.warn('⚠️ Manual column detection failed:', error);
        }
    }

    // Enhanced graph rendering with advanced features
    function renderEnhancedGraph(graph) {
        const {nodes, edges} = graph;
        console.log('🎨 Rendering enhanced graph with', nodes.length, 'nodes and', edges.length, 'edges');

        const width = enhancedSvg.attr('width');
        const height = enhancedSvg.attr('height');
        const graphGroup = enhancedSvg.select('.graph-group');

        graphGroup.selectAll('*').remove();

        // Add organelles to nodes (internal components) - REMOVED
        nodes.forEach(node => {
            // Remove organelles creation
            if (!node.activity) {
                node.activity = 0;
            }
            if (!node.pulse) {
                node.pulse = 0;
            }
        });

        // Enhanced simulation with dynamic forces
        // Enhanced simulation with dynamic forces
        enhancedSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(edges).id(d => d.id).distance(d => {
                return 120 + (1 - (d.strength || 0.5)) * 80; // Increased distances
            }).strength(0.8))
            .force('charge', d3.forceManyBody().strength(d => {
                const importance = d.importance || 0;
                return -600 - (importance / 100); // Increased repulsion
            }))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => getEnhancedNodeRadius(d) + 20)); // Increased collision buffer

        // Enhanced links
        // Enhanced links with proper arrow assignment
        const linkGroup = graphGroup.append('g').attr('class', 'links');
        const link = linkGroup.selectAll('line')
            .data(edges)
            .enter().append('line')
            .attr('class', d => {
                const strength = d.strength || 0.5;
                const strengthClass = strength > 0.7 ? 'high' : strength > 0.4 ? 'medium' : 'low';
                return `link link-${d.relationship_type?.replace('_', '-')} link-strength-${strengthClass}`;
            })
            .attr('stroke-width', 1.5)
            .attr('stroke', d => getLinkColor(d))
            .attr('stroke-dasharray', '3,2')
            .attr('marker-end', d => {
                // Ensure arrow is always assigned
                const importance = calculateLinkImportance(d);
                return `url(#arrowhead-importance-${importance})`;
            })
            .style('opacity', 0.8) // Make links slightly transparent
            .on('click', handleEnhancedLinkClick)
            .on('mouseover', handleEnhancedLinkMouseOver)
            .on('mouseout', handleMouseOut);

        // Enhanced nodes with sophisticated rendering
        const nodeGroup = graphGroup.append('g').attr('class', 'nodes');

        // Create node groups for complex rendering
        const nodeContainer = nodeGroup.selectAll('g.node-container')
            .data(nodes)
            .enter().append('g')
            .attr('class', 'node-container')
            .on('click', handleEnhancedNodeClick)
            .on('mouseover', handleEnhancedNodeMouseOver)
            .on('mouseout', handleMouseOut)
            .on('dblclick', handleNodeDoubleClick)
            .call(d3.drag()
                .on('start', dragStarted)
                .on('drag', dragged)
                .on('end', dragEnded));

        // Activity rings (outer glow effect)
        nodeContainer.append('circle')
            .attr('class', 'node-activity-ring')
            .attr('r', d => getEnhancedNodeRadius(d) + 12)
            .style('display', 'none');

        // Main node circle with membrane effect
        nodeContainer.append('circle')
            .attr('class', d => `node node-${d.category}`)
            .attr('r', getEnhancedNodeRadius)
            .style('filter', d => {
                const importance = d.importance || 0;
                return importance > 1000 ? 'drop-shadow(0 0 12px rgba(102, 126, 234, 0.8))' : null;
            });

        // Enhanced node labels - positioned within the node containers
        nodeContainer.append('text')
            .attr('class', 'node-label')
            .style('font-size', d => `${Math.max(12, getEnhancedNodeRadius(d) * 0.3)}px`)
            .style('font-weight', '600')
            .style('text-anchor', 'middle')
            .style('dominant-baseline', 'central')
            .style('pointer-events', 'none')
            .style('fill', '#2d3748')
            .style('paint-order', 'stroke')
            .style('stroke', 'white')
            .style('stroke-width', '3px')
            .style('stroke-linejoin', 'round')
            .text(d => d.name);

        // Internal organelles (like cellular components)
        nodeContainer.each(function (d) {
            const container = d3.select(this);

            if (d.organelles && d.organelles.length > 0) {
                d.organelles.forEach(organelle => {
                    container.append('circle')
                        .attr('class', 'node-organelle')
                        .attr('cx', organelle.x)
                        .attr('cy', organelle.y)
                        .attr('r', organelle.radius)
                        .style('fill', organelle.color);
                });
            }
        });

        // Central core (representing primary key or main identifier)
        // Central core (representing primary key or main identifier)
        nodeContainer.append('circle')
            .attr('class', 'node-core')
            .attr('r', d => Math.max(8, getEnhancedNodeRadius(d) * 0.15)) // Dynamic sizing based on node
            .style('fill', 'rgba(255, 255, 255, 0.9)')
            .style('stroke', 'rgba(0, 0, 0, 0.3)')
            .style('stroke-width', 1);


        // Link labels
        const linkLabelGroup = graphGroup.append('g').attr('class', 'link-labels');
        const linkLabel = linkLabelGroup.selectAll('text')
            .data(edges)
            .enter().append('text')
            .attr('class', 'link-label')
            .style('display', 'none')
            .text(d => getLinkLabelText(d));

        // Enhanced animation loop with organic movement
        // Enhanced animation loop with organic movement
        enhancedSimulation.on('tick', () => {
            // Update node activity
            nodes.forEach(node => {
                node.pulse += 0.03;
                if (node.activity > 0) {
                    node.activity = Math.max(0, node.activity - 0.005);
                }
            });

            // Update links
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            // Update node containers (includes circles and labels together)
            nodeContainer
                .attr('transform', d => `translate(${d.x},${d.y})`);

            // Update activity rings
            nodeContainer.selectAll('.node-activity-ring')
                .style('display', d => d.activity > 0.1 ? 'block' : 'none')
                .attr('r', d => getEnhancedNodeRadius(d) + 12 + (d.activity * 20));

            // Update link labels
            linkLabel
                .attr('x', d => getLinkLabelX(d))
                .attr('y', d => getLinkLabelY(d));
        });

        // Initialize highlighting and filters
        updateHighlighting();
        updateEdgeLabels();

        // At the end of renderEnhancedGraph function, add:
        // Apply special effects for one-to-many relationships
        setTimeout(() => {
            applyOneToManyEffects();
        }, 1000);

        console.log('✅ Enhanced graph rendered with organic effects and special transitions');
    }

    function createNodeOrganelles(node) {
        const count = Math.max(4, Math.min(15, (node.column_count || node.columns || 5))); // Increased count
        const organelles = [];

        for (let i = 0; i < count; i++) {
            organelles.push({
                x: (Math.random() - 0.5) * 80,  // Increased spread
                y: (Math.random() - 0.5) * 80,  // Increased spread
                radius: 3 + Math.random() * 6,   // Increased size (was 2 + Math.random() * 4)
                speed: 0.3 + Math.random() * 0.8,
                angle: Math.random() * Math.PI * 2,
                color: getOrganelleColor(node.category)
            });
        }
        return organelles;
    }

    function getOrganelleColor(category) {
        const colors = {
            'entity': 'rgba(102, 126, 234, 0.6)',
            'transaction': 'rgba(72, 187, 120, 0.6)',
            'lookup': 'rgba(237, 137, 54, 0.6)',
            'data': 'rgba(66, 153, 225, 0.6)'
        };
        return colors[category] || 'rgba(160, 160, 160, 0.6)';
    }

    // Enhanced node sizing with multiple factors
    function getEnhancedNodeRadius(d) {
        const mode = document.getElementById('nodeSizeMode').value;
        const baseSize = 25; // Increased from 12 to 25
        const maxSize = 60;   // Increased from 35 to 60

        // Safe access to properties with fallbacks
        const rowCount = d.row_count || d.rows || 0;
        const columnCount = d.column_count || d.columns || 0;
        const foreignKeyCount = d.foreign_key_count || d.foreign_keys || 0;
        const importance = d.importance || 0;

        switch (mode) {
            case 'rows':
                return Math.max(baseSize, Math.min(maxSize, baseSize + Math.log10(rowCount + 1) * 6)); // Increased multiplier
            case 'columns':
                return Math.max(baseSize, Math.min(maxSize, baseSize + columnCount * 1.2)); // Increased multiplier
            case 'relationships':
                return Math.max(baseSize, Math.min(maxSize, baseSize + foreignKeyCount * 6)); // Increased multiplier
            case 'importance':
                return Math.max(baseSize, Math.min(maxSize, baseSize + Math.log10(importance + 1) * 5)); // Increased multiplier
            case 'uniform':
            default:
                return baseSize;
        }
    }

    // Enhanced event handlers
    function handleEnhancedNodeClick(event, d) {
        event.stopPropagation();

        selectedNode = d;
        selectedLink = null;

        // Enhanced visual feedback
        enhancedSvg.selectAll('.node').classed('selected', false).classed('highlighted', false);
        enhancedSvg.selectAll('.link').classed('selected', false).classed('highlighted', false);

        d3.select(this).classed('selected', true);

        // Highlight connected nodes and links
        highlightConnectedElements(d);

        // Show enhanced node details
        showEnhancedNodeDetails(d);

        // Switch to details tab
        switchTab('details');
        document.querySelector('[onclick="switchTab(\'details\')"]').classList.add('active');

        console.log('🔍 Selected node:', d.name);
    }

    function handleEnhancedLinkClick(event, d) {
        event.stopPropagation();

        selectedLink = d;
        selectedNode = null;

        enhancedSvg.selectAll('.node').classed('selected', false).classed('highlighted', false);
        enhancedSvg.selectAll('.link').classed('selected', false).classed('highlighted', false);

        d3.select(this).classed('selected', true);

        showEnhancedLinkDetails(d);

        // Switch to details tab
        switchTab('details');
        document.querySelector('[onclick="switchTab(\'details\')"]').classList.add('active');

        console.log('🔗 Selected relationship:', d.source.name, '→', d.target.name);
    }

    function handleNodeDoubleClick(event, d) {
        // Zoom to node and its neighborhood
        const connectedNodes = getConnectedNodes(d);
        zoomToNodes([d, ...connectedNodes]);
    }

    function handleEnhancedNodeMouseOver(event, d) {
        const tooltip = d3.select('#tooltip');

        // Show activity ring
        d3.select(this.parentNode).select('.node-activity-ring')
            .style('display', 'block')
            .style('stroke-opacity', 0.6);

        // Trigger activity
        d.activity = Math.min(1, d.activity + 0.3);

        const connectedCount = getConnectedNodes(d).length;
        const strengthScore = calculateNodeStrength(d);

        // Safe access to properties with fallbacks
        const rowCount = d.row_count || d.rows || 0;
        const columnCount = d.column_count || d.columns || 0;

        let foreignKeyCount = d.foreign_key_count || d.foreign_keys || 0;
        if (foreignKeyCount === 0 && enhancedGraphData && enhancedGraphData.graph) {
            const outgoingRels = enhancedGraphData.graph.edges.filter(e =>
                (e.source.id || e.source.name || e.source) === (d.id || d.name)
            );
            if (outgoingRels.length > 0) {
                foreignKeyCount = outgoingRels.length;
            }
        }

        const importance = d.importance || 0;
        const category = d.category || d.type || 'Unknown';

        // Calculate performance metrics
        const performanceScore = calculatePerformanceScore(d);
        const healthStatus = getHealthStatus(d);

        // Get foreign key relationships
        const foreignKeyInfo = getForeignKeyRelationships(d);

        tooltip.style('display', 'block')
            .style('left', (event.pageX + 15) + 'px')
            .style('top', (event.pageY - 10) + 'px')
            .html(`
        <div class="tooltip-header">
            ${getServiceIcon(category)} ${d.name || d.id}
        </div>
        <div class="tooltip-section">
            <div class="tooltip-label">Category:</div>
            <div class="tooltip-value">${category}</div>
        </div>
        <div class="tooltip-section">
            <div class="tooltip-label">Structure:</div>
            <div class="tooltip-value">
                ${rowCount > 0 ? rowCount.toLocaleString() + ' rows' : 'Unknown rows'} •
                ${columnCount > 0 ? columnCount + ' columns' : 'Unknown columns'}
            </div>
        </div>
        <div class="tooltip-section">
            <div class="tooltip-label">Relationships:</div>
            <div class="tooltip-value">
                ${foreignKeyCount} foreign keys • ${connectedCount} connections
            </div>
        </div>
        ${foreignKeyInfo.outgoing.length > 0 ? `
        <div class="tooltip-section">
            <div class="tooltip-label">References:</div>
            <div class="tooltip-value">
                ${foreignKeyInfo.outgoing.map(rel =>
                `→ ${rel.targetTable}.${rel.targetColumn}`
            ).join('<br>')}
            </div>
        </div>
        ` : ''}
        ${foreignKeyInfo.incoming.length > 0 ? `
        <div class="tooltip-section">
            <div class="tooltip-label">Referenced by:</div>
            <div class="tooltip-value">
                ${foreignKeyInfo.incoming.map(rel =>
                `← ${rel.sourceTable}.${rel.sourceColumn}`
            ).join('<br>')}
            </div>
        </div>
        ` : ''}
        <div class="tooltip-section">
            <div class="tooltip-label">Performance:</div>
            <div class="tooltip-value">
                ${healthStatus} • Score: ${performanceScore.toFixed(1)}/10
            </div>
        </div>
        <div class="tooltip-section">
            <div class="tooltip-label">Importance:</div>
            <div class="tooltip-value">
                ${importance > 0 ? importance.toLocaleString() : 'Not calculated'}
                (Strength: ${strengthScore.toFixed(2)})
            </div>
        </div>
        ${getOptimizationTips(d)}
    `);
    }

    // Helper function to get foreign key relationships for a node
    function getForeignKeyRelationships(node) {
        if (!enhancedGraphData || !enhancedGraphData.graph || !enhancedGraphData.graph.edges) {
            return {outgoing: [], incoming: []};
        }

        const nodeId = node.id || node.name;
        const outgoing = [];
        const incoming = [];

        enhancedGraphData.graph.edges.forEach(edge => {
            const sourceId = edge.source.id || edge.source.name || edge.source;
            const targetId = edge.target.id || edge.target.name || edge.target;

            if (sourceId === nodeId) {
                outgoing.push({
                    sourceTable: edge.source.name || edge.source.id || edge.source,
                    sourceColumn: edge.from_column || 'unknown',
                    targetTable: edge.target.name || edge.target.id || edge.target,
                    targetColumn: edge.to_column || 'unknown',
                    strength: edge.strength || 0.5
                });
            }

            if (targetId === nodeId) {
                incoming.push({
                    sourceTable: edge.source.name || edge.source.id || edge.source,
                    sourceColumn: edge.from_column || 'unknown',
                    targetTable: edge.target.name || edge.target.id || edge.target,
                    targetColumn: edge.to_column || 'unknown',
                    strength: edge.strength || 0.5
                });
            }
        });

        return {outgoing, incoming};
    }


    function handleEnhancedLinkMouseOver(event, d) {
        const tooltip = d3.select('#tooltip');

        const cardinalityInfo = getCardinalityDescription(d.relationship_type);
        const strengthClass = d.strength > 0.7 ? 'High' : d.strength > 0.4 ? 'Medium' : 'Low';

        tooltip.style('display', 'block')
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px')
            .html(`
                <div style="border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 5px;">
                    <strong>${d.source.name} → ${d.target.name}</strong>
                </div>
                <div><strong>Type:</strong> ${cardinalityInfo}</div>
                <div><strong>Column:</strong> ${d.from_column} → ${d.to_column}</div>
                <div><strong>Strength:</strong> ${strengthClass} (${(d.strength * 100).toFixed(1)}%)</div>
                <div><strong>On Delete:</strong> ${d.on_delete}</div>
                <div><strong>On Update:</strong> ${d.on_update}</div>
                <div><strong>Performance Impact:</strong> ${getPerformanceImpact(d)}</div>
            `);
    }

    // Enhanced highlighting system
    function highlightConnectedElements(node) {
        if (!enhancedGraphData) return;

        const connectedNodeIds = new Set();
        const connectedLinkIds = new Set();

        enhancedGraphData.graph.edges.forEach(edge => {
            if (edge.source.id === node.id) {
                connectedNodeIds.add(edge.target.id);
                connectedLinkIds.add(edge.id);
            } else if (edge.target.id === node.id) {
                connectedNodeIds.add(edge.source.id);
                connectedLinkIds.add(edge.id);
            }
        });

        // Apply highlighting
        enhancedSvg.selectAll('.node')
            .classed('highlighted', d => connectedNodeIds.has(d.id));

        enhancedSvg.selectAll('.link')
            .classed('highlighted', d => connectedLinkIds.has(d.id))
            .attr('marker-end', d => {
                if (connectedLinkIds.has(d.id)) {
                    return 'url(#arrowhead-highlighted)';
                } else {
                    return `url(#arrowhead-importance-${calculateLinkImportance(d)})`;
                }
            });
    }

    function updateHighlighting() {
        const mode = document.getElementById('highlightMode').value;

        // Reset all highlighting
        enhancedSvg.selectAll('.node').classed('highlighted', false);
        enhancedSvg.selectAll('.link').classed('highlighted', false);

        if (!enhancedGraphData || mode === 'none') return;

        const nodes = enhancedGraphData.graph.nodes;
        const edges = enhancedGraphData.graph.edges;

        switch (mode) {
            case 'connected':
                // Highlight nodes with relationships
                const connectedNodeIds = new Set();
                edges.forEach(edge => {
                    connectedNodeIds.add(edge.source.id);
                    connectedNodeIds.add(edge.target.id);
                });
                enhancedSvg.selectAll('.node')
                    .classed('highlighted', d => connectedNodeIds.has(d.id));
                break;

            case 'orphaned':
                // Highlight orphaned nodes
                const connectedIds = new Set();
                edges.forEach(edge => {
                    connectedIds.add(edge.source.id);
                    connectedIds.add(edge.target.id);
                });
                enhancedSvg.selectAll('.node')
                    .classed('highlighted', d => !connectedIds.has(d.id));
                break;

            case 'central':
                // Highlight central nodes (high connectivity)
                const connectivity = {};
                edges.forEach(edge => {
                    connectivity[edge.source.id] = (connectivity[edge.source.id] || 0) + 1;
                    connectivity[edge.target.id] = (connectivity[edge.target.id] || 0) + 1;
                });
                const maxConnectivity = Math.max(...Object.values(connectivity));
                const threshold = maxConnectivity * 0.7;

                enhancedSvg.selectAll('.node')
                    .classed('highlighted', d => (connectivity[d.id] || 0) >= threshold);
                break;
        }
    }

    // Enhanced details display
    // 3. Fixed Node Details Display
    // Enhanced Node Details Display with better layout
    function showEnhancedNodeDetails(node) {
        const detailsEl = document.getElementById('relationshipDetails');

        // Find relationships for this node
        const outgoingRels = enhancedGraphData.graph.edges.filter(e => e.source.id === node.id);
        const incomingRels = enhancedGraphData.graph.edges.filter(e => e.target.id === node.id);

        // Safe access to properties with fallbacks
        const rowCount = node.row_count || node.rows || 0;
        const columnCount = node.column_count || node.columns || 0;

        let foreignKeyCount = node.foreign_key_count || node.foreign_keys || 0;
        if (foreignKeyCount === 0 && outgoingRels.length > 0) {
            foreignKeyCount = outgoingRels.length;
        }

        const importance = node.importance || 0;
        const category = node.category || node.type || 'Unknown';
        const objectType = node.type || 'table';

        // Calculate relationship statistics
        const totalRelationships = outgoingRels.length + incomingRels.length;
        const avgStrength = totalRelationships > 0 ?
            [...outgoingRels, ...incomingRels].reduce((sum, rel) => sum + (rel.strength || 0.5), 0) / totalRelationships : 0;

        detailsEl.innerHTML = `
        <div class="relationship-card">
            <h4>${getServiceIcon(category)} ${node.name || node.id}</h4>

            <!-- Basic Information Section -->
            <div class="table-info-section">
                <h5>📋 Basic Information</h5>
                <div class="table-info-grid">
                    <div class="info-item">
                        <span class="info-label">Object Type</span>
                        <span class="info-value">${objectType.charAt(0).toUpperCase() + objectType.slice(1)}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Category</span>
                        <span class="info-value">${category}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Row Count</span>
                        <span class="info-value">${rowCount > 0 ? rowCount.toLocaleString() : 'Unknown'}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Column Count</span>
                        <span class="info-value">${columnCount > 0 ? columnCount : 'Unknown'}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Foreign Keys</span>
                        <span class="info-value">${foreignKeyCount}</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Importance Score</span>
                        <span class="info-value">${importance > 0 ? importance.toLocaleString() : 'Not calculated'}</span>
                    </div>
                </div>
            </div>

            <!-- Relationship Statistics -->
            <div class="analysis-metrics">
                <div class="metric-item">
                    <div class="value">${outgoingRels.length}</div>
                    <div class="label">References</div>
                </div>
                <div class="metric-item">
                    <div class="value">${incomingRels.length}</div>
                    <div class="label">Referenced By</div>
                </div>
                <div class="metric-item">
                    <div class="value">${totalRelationships}</div>
                    <div class="label">Total Relations</div>
                </div>
                <div class="metric-item">
                    <div class="value">${(avgStrength * 100).toFixed(0)}%</div>
                    <div class="label">Avg Strength</div>
                </div>
            </div>

            ${outgoingRels.length > 0 ? `
                <h5>🔗 References (${outgoingRels.length})</h5>
                <div style="margin-bottom: 20px;">
                    ${outgoingRels.map(rel => `
                        <div class="relationship-info">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                <div>
                                    <strong>${rel.target.name || rel.target.id}</strong>
                                    <span style="color: #718096; margin-left: 8px;">.${rel.to_column || 'unknown'}</span>
                                </div>
                                <span class="relationship-strength strength-${getStrengthClass(rel.strength || 0.5)}">
                                    ${((rel.strength || 0.5) * 100).toFixed(0)}%
                                </span>
                            </div>
                            <small>
                                <strong>Relationship:</strong> ${rel.from_column || 'unknown'} → ${rel.to_column || 'unknown'}
                                <br><strong>Type:</strong> ${getCardinalityDescription(rel.relationship_type)}
                                ${rel.on_delete ? `<br><strong>On Delete:</strong> ${rel.on_delete}` : ''}
                                ${rel.on_update ? `<br><strong>On Update:</strong> ${rel.on_update}` : ''}
                            </small>
                        </div>
                    `).join('')}
                </div>
            ` : ''}

            ${incomingRels.length > 0 ? `
                <h5>⬅️ Referenced By (${incomingRels.length})</h5>
                <div style="margin-bottom: 20px;">
                    ${incomingRels.map(rel => `
                        <div class="relationship-info">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                <div>
                                    <strong>${rel.source.name || rel.source.id}</strong>
                                    <span style="color: #718096; margin-left: 8px;">.${rel.from_column || 'unknown'}</span>
                                </div>
                                <span class="relationship-strength strength-${getStrengthClass(rel.strength || 0.5)}">
                                    ${((rel.strength || 0.5) * 100).toFixed(0)}%
                                </span>
                            </div>
                            <small>
                                <strong>Relationship:</strong> ${rel.from_column || 'unknown'} → ${rel.to_column || 'unknown'}
                                <br><strong>Type:</strong> ${getCardinalityDescription(rel.relationship_type)}
                                ${rel.on_delete ? `<br><strong>On Delete:</strong> ${rel.on_delete}` : ''}
                                ${rel.on_update ? `<br><strong>On Update:</strong> ${rel.on_update}` : ''}
                            </small>
                        </div>
                    `).join('')}
                </div>
            ` : ''}

            ${totalRelationships === 0 ? `
                <div style="text-align: center; padding: 30px; color: #718096; background: #f7fafc; border-radius: 8px; margin: 20px 0;">
                    <div style="font-size: 2em; margin-bottom: 10px;">🏝️</div>
                    <div style="font-size: 1.1em; font-weight: 500;">No Relationships Found</div>
                    <div style="font-size: 0.9em; margin-top: 5px;">This ${objectType} appears to be isolated in the schema</div>
                </div>
            ` : ''}

            <!-- Action Buttons -->
            <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                <button class="btn btn-primary" onclick="generateJoinFromNode('${node.name || node.id}')" style="margin-right: 10px;">
                    🔗 Generate JOINs
                </button>
                <button class="btn btn-secondary" onclick="analyzeNodePerformance('${node.name || node.id}')">
                    📊 Analyze Performance
                </button>
                ${objectType === 'table' ? `
                    <button class="btn btn-info" onclick="showTableSchema('${node.name || node.id}')" style="margin-top: 8px;">
                        📋 View Schema
                    </button>
                ` : ''}
                ${totalRelationships > 0 ? `
                    <button class="btn btn-success" onclick="generateRelationshipReport('${node.name || node.id}')" style="margin-top: 8px;">
                        📑 Relationship Report
                    </button>
                ` : ''}
            </div>
        </div>
    `;
    }

    function showEnhancedLinkDetails(link) {
        const detailsEl = document.getElementById('relationshipDetails');

        const cardinalityInfo = getCardinalityDescription(link.relationship_type);
        const strengthClass = getStrengthClass(link.strength);
        const performanceImpact = getPerformanceImpact(link);

        detailsEl.innerHTML = `
        <div class="relationship-card">
            <h4>🔗 Relationship Analysis</h4>
            <div style="margin-bottom: 10px;">
                <strong>From:</strong> ${link.source.name}.${link.from_column}<br>
                <strong>To:</strong> ${link.target.name}.${link.to_column}<br>
                <strong>Type:</strong> ${cardinalityInfo}
            </div>

            <div class="analysis-metrics">
                <div class="metric-item">
                    <div class="value strength-${strengthClass}">${(link.strength * 100).toFixed(0)}%</div>
                    <div class="label">Strength</div>
                </div>
                <div class="metric-item">
                    <div class="value">${performanceImpact}</div>
                    <div class="label">Performance</div>
                </div>
            </div>

            <div style="margin-top: 10px;">
                <strong>Constraints:</strong><br>
                <small>On Delete: ${link.on_delete}</small><br>
                <small>On Update: ${link.on_update}</small>
            </div>

            <div style="margin-top: 15px;">
                <button class="btn btn-sm" onclick="generateJoinFromLink('${link.source.name}', '${link.target.name}', '${link.from_column}', '${link.to_column}')" style="margin-right: 5px;">
                    🔗 Generate JOIN
                </button>
                <button class="btn btn-warning btn-sm" onclick="analyzeRelationshipPerformance('${link.source.name}', '${link.target.name}')">
                    ⚡ Performance Tips
                </button>
            </div>
        </div>
    `;
    }

    // Function to categorize database objects
    function getObjectCategory(type) {
        switch (type) {
            case 'table':
                return 'entity'; // Default for tables
            case 'view':
                return 'view';
            case 'index':
                return 'index';
            case 'trigger':
                return 'trigger';
            default:
                return 'data';
        }
    }

    // Function to calculate object importance
    function calculateObjectImportance(dbObject) {
        let importance = 100; // Base importance

        switch (dbObject.type) {
            case 'table':
                importance = 1000; // Tables are most important
                break;
            case 'view':
                importance = 500; // Views are moderately important
                break;
            case 'index':
                importance = 300; // Indexes are performance-related
                break;
            case 'trigger':
                importance = 400; // Triggers are business logic
                break;
        }

        // Boost importance for objects with relationships
        if (dbObject.related_objects && dbObject.related_objects.length > 0) {
            importance += dbObject.related_objects.length * 50;
        }

        return importance;
    }

    // Enhanced service icon function
    function getServiceIcon(category) {
        const icons = {
            'entity': '🏛️',
            'transaction': '💰',
            'lookup': '📋',
            'data': '📊',
            'view': '👁️',
            'index': '🗂️',
            'trigger': '⚡'
        };
        return icons[category] || '🗄️';
    }

    function calculatePerformanceScore(node) {
        let score = 5; // Base score

        const rowCount = node.row_count || node.rows || 0;
        const columnCount = node.column_count || node.columns || 0;
        const foreignKeyCount = node.foreign_key_count || node.foreign_keys || 0;

        // Score based on size efficiency
        if (rowCount > 0 && columnCount > 0) {
            const efficiency = rowCount / (columnCount * 1000);
            score += Math.min(2, efficiency);
        }

        // Score based on relationships
        if (foreignKeyCount > 0) score += 1;
        if (foreignKeyCount > 3) score += 1;

        // Score based on connectivity
        const connectedCount = getConnectedNodes(node).length;
        if (connectedCount > 0) score += 1;

        return Math.min(10, Math.max(1, score));
    }

    function getHealthStatus(node) {
        const performanceScore = calculatePerformanceScore(node);
        if (performanceScore >= 8) return '🟢 Excellent';
        if (performanceScore >= 6) return '🟡 Good';
        if (performanceScore >= 4) return '🟠 Fair';
        return '🔴 Needs Attention';
    }

    function getOptimizationTips(node) {
        const tips = [];
        const rowCount = node.row_count || node.rows || 0;
        const foreignKeyCount = node.foreign_key_count || node.foreign_keys || 0;

        if (rowCount > 10000 && foreignKeyCount > 0) {
            tips.push('💡 Consider indexing for large table');
        }
        if (foreignKeyCount === 0) {
            tips.push('⚠️ No foreign keys detected');
        }
        if (getConnectedNodes(node).length === 0) {
            tips.push('🏝️ Isolated table - consider relationships');
        }

        return tips.length > 0 ? `
        <div class="tooltip-section">
            <div class="tooltip-label">Tips:</div>
            <div class="tooltip-value" style="font-size: 0.75em;">
                ${tips.join('<br>')}
            </div>
        </div>
    ` : '';
    }

    // Enhanced metrics and analysis
    function updateEnhancedMetrics(graphMetrics, relationshipMetrics) {
        document.getElementById('totalTables').textContent = graphMetrics.total_tables;
        document.getElementById('totalRelationships').textContent = graphMetrics.total_relationships;

        const connectivityRatio = ((graphMetrics.connected_tables / graphMetrics.total_tables) * 100).toFixed(0);
        document.getElementById('connectivityRatio').textContent = connectivityRatio + '%';

        if (relationshipMetrics) {
            const complexityScore = relationshipMetrics.complexity?.complexity_score || 0;
            document.getElementById('complexityScore').textContent = complexityScore.toFixed(1);

            // Update health metrics
            const integrityScore = relationshipMetrics.integrity?.integrity_score || 0;
            const orphanedCount = relationshipMetrics.integrity?.orphaned_records || 0;

            document.getElementById('integrityScore').textContent = integrityScore + '%';
            document.getElementById('orphanedCount').textContent = orphanedCount;

            // Update health status
            const healthEl = document.getElementById('healthStatus');
            let statusClass = 'status-good';
            let statusText = 'Excellent';

            if (integrityScore < 70 || orphanedCount > 10) {
                statusClass = 'status-error';
                statusText = 'Issues Found';
            } else if (integrityScore < 90 || orphanedCount > 0) {
                statusClass = 'status-warning';
                statusText = 'Minor Issues';
            }

            healthEl.innerHTML = `
            <span class="status-indicator ${statusClass}"></span>
            <span>${statusText}</span>
        `;
        }
    }

    function updateAnalysisInsights(analysis, summary) {
        const insightsEl = document.getElementById('aiInsights');
        const insights = [];

        if (summary.orphaned_records > 0) {
            insights.push(`⚠️ ${summary.orphaned_records} orphaned records detected`);
        }

        if (analysis.recommendations && analysis.recommendations.length > 0) {
            insights.push(`💡 ${analysis.recommendations.length} optimization opportunities`);
        }

        if (summary.total_relationships === 0) {
            insights.push(`🔍 No foreign key relationships found - consider adding constraints`);
        } else {
            insights.push(`✅ ${summary.total_relationships} relationships analyzed`);
        }

        if (insights.length === 0) {
            insights.push('🎉 All relationship checks passed!');
        }

        insightsEl.innerHTML = insights.map(insight =>
            `<div style="margin-bottom: 8px; padding: 4px 8px; background: rgba(102, 126, 234, 0.1); border-radius: 4px; font-size: 0.85em;">${insight}</div>`
        ).join('');
    }

    // Enhanced path finding
    // Enhanced path finding for all database object types
    async function findOptimalPath() {
        const fromTable = document.getElementById('pathFromTable').value;
        const toTable = document.getElementById('pathToTable').value;

        if (!fromTable || !toTable) {
            showMessage('Please select both objects', 'warning');
            return;
        }

        if (fromTable === toTable) {
            showMessage('Please select different objects', 'warning');
            return;
        }

        try {
            showLoading(true, 'Finding optimal path between database objects...');

            // First try the API endpoint
            let result = null;
            try {
                const response = await fetch(API_ENDPOINTS.joinPaths, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        start_table: fromTable,
                        end_table: toTable,
                        max_hops: 5 // Increased from 3
                    })
                });
                result = await response.json();
            } catch (apiError) {
                console.warn('API path finding failed, using local analysis:', apiError);
            }

            // If API fails or returns no path, try local path finding
            if (!result || !result.success) {
                console.log('🔍 Attempting local path finding...');
                result = await findPathLocally(fromTable, toTable);
            }

            if (result.success && result.path) {
                displayJoinPath(result.path);
                highlightPath(result.path.tables || result.path.objects);
                showMessage('✅ Path found successfully!', 'success');
            } else {
                // Show more detailed error message
                const errorMsg = result.error || 'No path found between the selected objects';
                showMessage(`❌ ${errorMsg}`, 'warning');

                // Suggest alternatives
                suggestAlternativePaths(fromTable, toTable);
            }

        } catch (error) {
            showMessage('Error finding path: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    // Local path finding for all database object types
    async function findPathLocally(fromObject, toObject) {
        try {
            console.log(`🔍 Finding local path from ${fromObject} to ${toObject}`);

            if (!enhancedGraphData || !enhancedGraphData.graph) {
                return { success: false, error: 'No graph data available' };
            }

            const { nodes, edges } = enhancedGraphData.graph;

            // Find the source and target nodes
            const sourceNode = nodes.find(n => (n.name || n.id) === fromObject);
            const targetNode = nodes.find(n => (n.name || n.id) === toObject);

            if (!sourceNode || !targetNode) {
                return { success: false, error: 'One or both objects not found in the graph' };
            }

            // Build enhanced adjacency list including all connection types
            const adjacencyList = await buildEnhancedAdjacencyList(nodes, edges);

            // Use BFS to find the shortest path
            const path = findShortestPath(adjacencyList, fromObject, toObject);

            if (path && path.length > 1) {
                const pathDetails = await generateEnhancedPathDetails(path, nodes, edges);
                return {
                    success: true,
                    path: pathDetails
                };
            } else {
                return { success: false, error: 'No connection path found between objects' };
            }

        } catch (error) {
            console.error('Local path finding error:', error);
            return { success: false, error: 'Error in local path analysis' };
        }
    }

    // Build enhanced adjacency list including all database object relationships
    // Build enhanced adjacency list including all database object relationships
    async function buildEnhancedAdjacencyList(nodes, edges) {
        const adjacencyList = {};

        // Initialize adjacency list
        nodes.forEach(node => {
            const nodeName = node.name || node.id;
            adjacencyList[nodeName] = new Set();
        });

        // Add foreign key relationships (bidirectional for path finding)
        edges.forEach(edge => {
            const sourceName = edge.source.name || edge.source.id || edge.source;
            const targetName = edge.target.name || edge.target.id || edge.target;

            if (adjacencyList[sourceName] && adjacencyList[targetName]) {
                adjacencyList[sourceName].add(targetName);
                adjacencyList[targetName].add(sourceName); // Bidirectional
            }
        });

        // Add derived relationships (views, indexes, triggers to their parent tables)
        nodes.forEach(node => {
            const nodeName = node.name || node.id;

            // If this is a view, index, or trigger, connect it to its parent table
            if (node.parent_table) {
                if (adjacencyList[nodeName] && adjacencyList[node.parent_table]) {
                    adjacencyList[nodeName].add(node.parent_table);
                    adjacencyList[node.parent_table].add(nodeName);
                }
            }

            // Connect related objects (indexes and triggers to their tables)
            if (node.related_objects && node.related_objects.length > 0) {
                node.related_objects.forEach(relatedObj => {
                    if (adjacencyList[nodeName] && adjacencyList[relatedObj.name]) {
                        adjacencyList[nodeName].add(relatedObj.name);
                        adjacencyList[relatedObj.name].add(nodeName);
                    }
                });
            }
        });

        // Add potential schema-based connections
        await addSchemaBasedConnections(adjacencyList, nodes);

        return adjacencyList;
    }

    // Add connections based on schema analysis (e.g., similar column names)
    async function addSchemaBasedConnections(adjacencyList, nodes) {
        try {
            // Get all table structures
            const tableStructures = {};

            for (const node of nodes) {
                if (node.type === 'table' || node.type === 'view') {
                    try {
                        const response = await fetch(`/api/table/${node.name}/structure`);
                        const result = await response.json();

                        if (result.success && result.structure && result.structure.columns) {
                            tableStructures[node.name] = result.structure.columns;
                        }
                    } catch (error) {
                        console.warn(`Could not get structure for ${node.name}`);
                    }
                }
            }

            // Find potential connections based on column names
            const tableNames = Object.keys(tableStructures);

            for (let i = 0; i < tableNames.length; i++) {
                for (let j = i + 1; j < tableNames.length; j++) {
                    const table1 = tableNames[i];
                    const table2 = tableNames[j];

                    const columns1 = tableStructures[table1] || [];
                    const columns2 = tableStructures[table2] || [];

                    // Look for matching column names that could indicate relationships
                    const hasMatchingColumns = columns1.some(col1 =>
                        columns2.some(col2 =>
                            col1.name === col2.name ||
                            col1.name.includes('_id') && col2.name.includes('_id') ||
                            col1.name.toLowerCase().includes(table2.toLowerCase()) ||
                            col2.name.toLowerCase().includes(table1.toLowerCase())
                        )
                    );

                    if (hasMatchingColumns && adjacencyList[table1] && adjacencyList[table2]) {
                        adjacencyList[table1].add(table2);
                        adjacencyList[table2].add(table1);
                    }
                }
            }

        } catch (error) {
            console.warn('Error in schema-based connection detection:', error);
        }
    }

    // BFS to find shortest path between objects
    function findShortestPath(adjacencyList, start, end) {
        const queue = [[start]];
        const visited = new Set([start]);

        while (queue.length > 0) {
            const path = queue.shift();
            const currentNode = path[path.length - 1];

            if (currentNode === end) {
                return path;
            }

            const neighbors = adjacencyList[currentNode] || new Set();

            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push([...path, neighbor]);
                }
            }
        }

        return null; // No path found
    }

    // Generate detailed path information
    async function generateEnhancedPathDetails(path, nodes, edges) {
        const pathDetails = {
            objects: path,
            tables: path, // For backward compatibility
            hops: path.length - 1,
            sql: '',
            connections: []
        };

        // Generate connection details and SQL
        let sqlParts = [];
        let fromClause = `FROM \`${path[0]}\` t0`;

        for (let i = 0; i < path.length - 1; i++) {
            const currentObj = path[i];
            const nextObj = path[i + 1];

            const currentNode = nodes.find(n => (n.name || n.id) === currentObj);
            const nextNode = nodes.find(n => (n.name || n.id) === nextObj);

            // Find the connection type
            const connection = findConnectionType(currentNode, nextNode, edges);
            pathDetails.connections.push(connection);

            // Add JOIN clause based on connection type
            const joinClause = generateJoinClause(connection, i + 1);
            if (joinClause) {
                fromClause += `\n${joinClause}`;
            }
        }

        // Generate complete SQL
        pathDetails.sql = `-- Path from ${path[0]} to ${path[path.length - 1]}
SELECT *
${fromClause}
LIMIT 100;`;

        return pathDetails;
    }

    // Find the type of connection between two nodes
    function findConnectionType(node1, node2, edges) {
        const name1 = node1.name || node1.id;
        const name2 = node2.name || node2.id;

        // Check for foreign key relationship
        const fkEdge = edges.find(edge =>
            (edge.source.name === name1 && edge.target.name === name2) ||
            (edge.source.name === name2 && edge.target.name === name1)
        );

        if (fkEdge) {
            return {
                type: 'foreign_key',
                from_column: fkEdge.from_column,
                to_column: fkEdge.to_column,
                relationship_type: fkEdge.relationship_type
            };
        }

        // Check for parent-child relationship (view, index, trigger)
        if (node1.parent_table === name2 || node2.parent_table === name1) {
            return {
                type: 'parent_child',
                parent: node1.parent_table === name2 ? name2 : name1,
                child: node1.parent_table === name2 ? name1 : name2
            };
        }

        // Check for related objects
        if (node1.related_objects?.some(obj => obj.name === name2) ||
            node2.related_objects?.some(obj => obj.name === name1)) {
            return {
                type: 'related_object',
                description: 'Related database object'
            };
        }

        // Default to schema-based connection
        return {
            type: 'schema_based',
            description: 'Potential connection based on schema analysis'
        };
    }

    // Generate JOIN clause based on connection type
    function generateJoinClause(connection, tableIndex) {
        const alias = `t${tableIndex}`;
        const prevAlias = `t${tableIndex - 1}`;

        switch (connection.type) {
            case 'foreign_key':
                return `LEFT JOIN \`${connection.to_table || 'target_table'}\` ${alias}
    ON ${prevAlias}.\`${connection.from_column}\` = ${alias}.\`${connection.to_column}\``;

            case 'parent_child':
                return `-- ${connection.child} is derived from ${connection.parent}`;

            case 'related_object':
                return `-- Related object connection`;

            case 'schema_based':
                return `-- Potential connection (verify column relationships)`;

            default:
                return `-- Connection via ${connection.type}`;
        }
    }

    // Suggest alternative paths when direct path is not found
    function suggestAlternativePaths(fromObject, toObject) {
        if (!enhancedGraphData || !enhancedGraphData.graph) return;

        const { nodes } = enhancedGraphData.graph;

        const fromNode = nodes.find(n => (n.name || n.id) === fromObject);
        const toNode = nodes.find(n => (n.name || n.id) === toObject);

        if (!fromNode || !toNode) return;

        const suggestions = [];

        // Check if objects are of different types
        if (fromNode.type !== toNode.type) {
            suggestions.push(`💡 ${fromObject} is a ${fromNode.type} and ${toObject} is a ${toNode.type}. Consider their relationship context.`);
        }

        // Check for parent relationships
        if (fromNode.parent_table) {
            suggestions.push(`🔗 ${fromObject} is derived from ${fromNode.parent_table}. Try path: ${fromNode.parent_table} → ${toObject}`);
        }

        if (toNode.parent_table) {
            suggestions.push(`🔗 ${toObject} is derived from ${toNode.parent_table}. Try path: ${fromObject} → ${toNode.parent_table}`);
        }

        // Show suggestions
        if (suggestions.length > 0) {
            const modal = createModal('💡 Path Suggestions', `
            <div style="padding: 20px;">
                <h4>Alternative Path Suggestions</h4>
                <p style="color: #666; margin-bottom: 15px;">
                    No direct path found between ${fromObject} and ${toObject}. Here are some suggestions:
                </p>
                <ul style="line-height: 1.6;">
                    ${suggestions.map(suggestion => `<li style="margin-bottom: 8px;">${suggestion}</li>`).join('')}
                </ul>
                <div style="margin-top: 20px; text-align: center;">
                    <button onclick="this.closest('.modal').remove()"
                            style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">
                        Close
                    </button>
                </div>
            </div>
        `);
            document.body.appendChild(modal);
        }
    }

    function displayJoinPath(path) {
        const previewEl = document.getElementById('joinPreview');

        if (!path || !path.sql) {
            previewEl.style.display = 'none';
            return;
        }

        previewEl.style.display = 'block';
        previewEl.innerHTML = `
        <div style="margin-bottom: 8px;">
            <strong>🛤️ Path:</strong> ${path.tables.join(' → ')}
        </div>
        <div style="margin-bottom: 8px;">
            <strong>📊 Complexity:</strong> ${path.hops} hops
        </div>
        <div style="font-family: monospace; font-size: 0.75em; background: #fff; padding: 8px; border-radius: 4px; overflow-x: auto;">
            ${path.sql}
        </div>
        <div style="margin-top: 8px;">
            <button onclick="copyToClipboard('${path.sql.replace(/'/g, "\\'")}'); showMessage('SQL copied to clipboard!', 'success')"
                    style="font-size: 0.7em; padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">
                📋 Copy SQL
            </button>
        </div>
    `;
    }

    function highlightPath(tables) {
        if (!enhancedGraphData || !tables) return;

        // Reset highlighting
        enhancedSvg.selectAll('.node').classed('highlighted', false);
        enhancedSvg.selectAll('.link').classed('highlighted', false);

        // Highlight path nodes
        enhancedSvg.selectAll('.node')
            .classed('highlighted', d => tables.includes(d.name));

        // Highlight path links
        for (let i = 0; i < tables.length - 1; i++) {
            const fromTable = tables[i];
            const toTable = tables[i + 1];

            enhancedSvg.selectAll('.link')
                .classed('highlighted', d =>
                    (d.source.name === fromTable && d.target.name === toTable) ||
                    (d.source.name === toTable && d.target.name === fromTable)
                );
        }
    }

    // Enhanced AI insights generation
    async function generateAIInsights() {
        const insightsEl = document.getElementById('aiInsights');

        if (!enhancedGraphData) {
            insightsEl.innerHTML = '<div style="color: #999;">No relationship data available</div>';
            return;
        }

        insightsEl.innerHTML = '<div style="color: #667eea;">🤖 Generating AI insights...</div>';

        try {
            // Simulate AI analysis based on relationship data
            const insights = await analyzeRelationshipsWithAI();

            insightsEl.innerHTML = insights.map(insight =>
                `<div style="margin-bottom: 8px; padding: 6px 10px; background: ${insight.color}; border-radius: 4px; font-size: 0.85em;">
                ${insight.icon} ${insight.text}
            </div>`
            ).join('');

        } catch (error) {
            insightsEl.innerHTML = '<div style="color: #dc3545;">Error generating insights</div>';
        }
    }

    async function analyzeRelationshipsWithAI() {
        const insights = [];
        const {nodes, edges} = enhancedGraphData.graph;

        // Analyze connectivity
        const isolatedNodes = nodes.filter(node =>
            !edges.some(edge => edge.source.id === node.id || edge.target.id === node.id)
        );

        if (isolatedNodes.length > 0) {
            insights.push({
                icon: '🏝️',
                text: `${isolatedNodes.length} isolated tables detected - consider adding relationships`,
                color: 'rgba(255, 193, 7, 0.1)'
            });
        }

        // Analyze relationship strength with safe access
        const weakRelationships = edges.filter(edge => (edge.strength || 0.5) < 0.3);
        if (weakRelationships.length > 0) {
            insights.push({
                icon: '⚠️',
                text: `${weakRelationships.length} weak relationships may indicate data quality issues`,
                color: 'rgba(220, 53, 69, 0.1)'
            });
        }

        // Analyze central nodes with safe property access
        const nodeConnectivity = {};
        edges.forEach(edge => {
            const sourceId = edge.source.id || edge.source;
            const targetId = edge.target.id || edge.target;
            nodeConnectivity[sourceId] = (nodeConnectivity[sourceId] || 0) + 1;
            nodeConnectivity[targetId] = (nodeConnectivity[targetId] || 0) + 1;
        });

        const centralNodes = Object.entries(nodeConnectivity)
            .filter(([nodeId, count]) => count >= 3)
            .map(([nodeId]) => nodes.find(n => (n.id || n.name) === nodeId))
            .filter(node => node); // Remove any undefined nodes

        if (centralNodes.length > 0) {
            insights.push({
                icon: '🌟',
                text: `${centralNodes.length} central tables identified - ensure proper indexing`,
                color: 'rgba(40, 167, 69, 0.1)'
            });
        }

        // Performance recommendations with safe property access
        const largeTablesWithManyRels = nodes.filter(node => {
            const rowCount = node.row_count || node.rows || 0;
            const connectivity = nodeConnectivity[node.id || node.name] || 0;
            return rowCount > 10000 && connectivity > 2;
        });

        if (largeTablesWithManyRels.length > 0) {
            insights.push({
                icon: '🚀',
                text: `${largeTablesWithManyRels.length} large tables with multiple relationships need optimization`,
                color: 'rgba(102, 126, 234, 0.1)'
            });
        }

        // Check for missing metadata
        const nodesWithMissingData = nodes.filter(node => {
            const rowCount = node.row_count || node.rows || 0;
            const columnCount = node.column_count || node.columns || 0;
            return rowCount === 0 || columnCount === 0;
        });

        if (nodesWithMissingData.length > 0) {
            insights.push({
                icon: '📊',
                text: `${nodesWithMissingData.length} tables missing size information - run ANALYZE to update statistics`,
                color: 'rgba(23, 162, 184, 0.1)'
            });
        }

        // Default positive insight
        if (insights.length === 0) {
            insights.push({
                icon: '✨',
                text: 'Relationship structure looks well-designed!',
                color: 'rgba(40, 167, 69, 0.1)'
            });
        }

        return insights;
    }

    function showMessage(message, type = 'info') {
        const alertClass = type === 'error' ? 'danger' : type;

        const alertEl = document.createElement('div');
        alertEl.className = `alert alert-${alertClass}`;
        alertEl.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        max-width: 400px;
        padding: 12px 16px;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        font-size: 0.9em;
        color: white;
        background: ${type === 'error' ? '#dc3545' : type === 'warning' ? '#ffc107' : type === 'success' ? '#28a745' : '#17a2b8'};
    `;

        alertEl.innerHTML = `
        ${message}
        <button type="button" onclick="this.parentElement.remove()" style="
            background: none; border: none; color: white; float: right;
            font-size: 18px; font-weight: bold; cursor: pointer; margin-left: 10px;
        ">×</button>
    `;

        document.body.appendChild(alertEl);

        setTimeout(() => {
            if (alertEl.parentNode) {
                alertEl.remove();
            }
        }, 5000);
    }

    function showLoading(show, message = 'Loading...') {
        const existingLoader = document.querySelector('.loading-overlay');

        if (show) {
            if (existingLoader) return;

            const loader = document.createElement('div');
            loader.className = 'loading-overlay';
            loader.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;

            loader.innerHTML = `
            <div style="background: white; padding: 30px; border-radius: 10px; text-align: center;">
                <div class="spinner" style="width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                <div style="color: #333; font-size: 16px;">${message}</div>
            </div>
        `;

            document.body.appendChild(loader);
        } else {
            if (existingLoader) {
                existingLoader.remove();
            }
        }
    }

    function copyToClipboard(text) {
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => {
                console.log('Text copied to clipboard');
            }).catch(err => {
                console.error('Could not copy text: ', err);
                fallbackCopyToClipboard(text);
            });
        } else {
            fallbackCopyToClipboard(text);
        }
    }

    function fallbackCopyToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
    }

    function downloadFile(content, filename) {
        const blob = new Blob([content], {type: 'text/plain'});
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }

    // Enhanced utility functions
    function getLinkLabelText(d) {
        const mode = document.getElementById('edgeLabelMode').value;

        switch (mode) {
            case 'columns':
                return `${d.from_column} → ${d.to_column}`;
            case 'type':
                return d.relationship_type.replace('_', ' ');
            case 'strength':
                return `${(d.strength * 100).toFixed(0)}%`;
            default:
                return '';
        }
    }

    function getLinkLabelX(d) {
        return (d.source.x + d.target.x) / 2;
    }

    function getLinkLabelY(d) {
        return (d.source.y + d.target.y) / 2;
    }

    function getConnectedNodes(node) {
        if (!enhancedGraphData) return [];

        const connected = [];
        enhancedGraphData.graph.edges.forEach(edge => {
            if (edge.source.id === node.id) {
                connected.push(edge.target);
            } else if (edge.target.id === node.id) {
                connected.push(edge.source);
            }
        });

        return connected;
    }

    function calculateNodeStrength(node) {
        const connectedEdges = enhancedGraphData.graph.edges.filter(edge =>
            edge.source.id === node.id || edge.target.id === node.id
        );

        if (connectedEdges.length === 0) return 0;

        const avgStrength = connectedEdges.reduce((sum, edge) => sum + edge.strength, 0) / connectedEdges.length;
        return avgStrength;
    }

    function getCardinalityDescription(relationshipType) {
        const descriptions = {
            'one_to_one': 'One-to-One',
            'one_to_many': 'One-to-Many',
            'many_to_one': 'Many-to-One',
            'many_to_many': 'Many-to-Many'
        };
        return descriptions[relationshipType] || relationshipType;
    }

    function getStrengthClass(strength) {
        if (strength > 0.7) return 'high';
        if (strength > 0.4) return 'medium';
        return 'low';
    }

    function getPerformanceImpact(link) {
        if (link.strength > 0.8) return 'Excellent';
        if (link.strength > 0.6) return 'Good';
        if (link.strength > 0.4) return 'Fair';
        return 'Poor';
    }

    function zoomToNodes(nodes) {
        if (!nodes || nodes.length === 0) return;

        const bounds = {
            minX: Math.min(...nodes.map(n => n.x)) - 50,
            maxX: Math.max(...nodes.map(n => n.x)) + 50,
            minY: Math.min(...nodes.map(n => n.y)) - 50,
            maxY: Math.max(...nodes.map(n => n.y)) + 50
        };

        const width = bounds.maxX - bounds.minX;
        const height = bounds.maxY - bounds.minY;
        const centerX = (bounds.minX + bounds.maxX) / 2;
        const centerY = (bounds.minY + bounds.maxY) / 2;

        const svgWidth = enhancedSvg.attr('width');
        const svgHeight = enhancedSvg.attr('height');

        const scale = 0.8 / Math.max(width / svgWidth, height / svgHeight);
        const translate = [svgWidth / 2 - scale * centerX, svgHeight / 2 - scale * centerY];

        enhancedSvg.transition().duration(1000).call(
            d3.zoom().transform,
            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
        );
    }

    function handleMouseOut() {
        const tooltip = d3.select('#tooltip');
        tooltip.style('display', 'none');
    }


    // Trigger node activity when interactions happen
    function triggerNodeActivity(nodeId, activityLevel = 0.5) {
        if (!enhancedGraphData) return;

        const node = enhancedGraphData.graph.nodes.find(n => n.id === nodeId || n.name === nodeId);
        if (node) {
            node.activity = Math.min(1, (node.activity || 0) + activityLevel);

            // Update visual activity ring
            enhancedSvg.selectAll('.node-container')
                .filter(d => d.id === nodeId || d.name === nodeId)
                .select('.node-activity-ring')
                .style('display', 'block')
                .style('stroke-opacity', 0.8);
        }
    }

    // Enhanced interaction feedback
    function addInteractionFeedback() {
        // Override some existing functions to add activity
        const originalGenerateJoinFromNode = window.generateJoinFromNode;
        window.generateJoinFromNode = function (nodeName) {
            triggerNodeActivity(nodeName, 0.7);
            return originalGenerateJoinFromNode(nodeName);
        };

        const originalAnalyzeNodePerformance = window.analyzeNodePerformance;
        window.analyzeNodePerformance = function (nodeName) {
            triggerNodeActivity(nodeName, 0.5);
            return originalAnalyzeNodePerformance(nodeName);
        };
    }

    // Initialize interaction feedback
    document.addEventListener('DOMContentLoaded', function () {
        setTimeout(addInteractionFeedback, 1000);
    });

    // Drag functions
    // Drag functions (Replace existing ones)
    function dragStarted(event, d) {
        if (!event.active && enhancedSimulation) enhancedSimulation.alphaTarget(0.3).restart();

        // Only set fixed position if we're in force mode or dragging
        if (currentLayout === 'force') {
            d.fx = d.x;
            d.fy = d.y;
        }
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;

        // For non-force layouts, immediately update position
        if (currentLayout !== 'force') {
            d.x = event.x;
            d.y = event.y;
        }
    }

    function dragEnded(event, d) {
        if (!event.active && enhancedSimulation) enhancedSimulation.alphaTarget(0);

        // Only clear fixed position in force mode
        if (currentLayout === 'force') {
            d.fx = null;
            d.fy = null;
        }
        // In other layouts, keep the position fixed where user dragged it
    }

    function displayOptimizationSuggestions(suggestions) {
        const container = document.getElementById('aiInsights');

        let html = '<h6>🔧 Optimization Suggestions</h6>';

        if (suggestions.length === 0) {
            html += '<div style="color: #28a745;">✅ No optimization suggestions - your schema looks good!</div>';
        } else {
            suggestions.forEach(suggestion => {
                const priorityColor = suggestion.priority === 'High' ? '#dc3545' :
                    suggestion.priority === 'Medium' ? '#ffc107' : '#6c757d';

                html += `
                <div style="margin-bottom: 10px; padding: 8px; border-left: 3px solid ${priorityColor}; background: rgba(0,0,0,0.02);">
                    <strong>${suggestion.title}</strong>
                    <span style="background: ${priorityColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.7em; margin-left: 8px;">
                        ${suggestion.priority}
                    </span>
                    <div style="font-size: 0.85em; margin-top: 4px;">${suggestion.description}</div>
                    <div style="font-size: 0.8em; color: #666; margin-top: 4px;">${suggestion.recommendation}</div>
                    ${suggestion.affected_tables ? `<div style="font-size: 0.75em; color: #007bff; margin-top: 2px;">Tables: ${suggestion.affected_tables.join(', ')}</div>` : ''}
                </div>
            `;
            });
        }

        container.innerHTML = html;
    }

    function displayRelationshipSuggestions(suggestions) {
        const container = document.getElementById('aiInsights');

        if (!suggestions || suggestions.length === 0) {
            container.innerHTML = '<div style="color: #28a745;">✅ No relationship suggestions needed!</div>';
            return;
        }

        let html = '<h6>🔗 Relationship Suggestions</h6>';

        suggestions.slice(0, 5).forEach(suggestion => {
            const confidenceColor = suggestion.confidence > 0.8 ? '#28a745' :
                suggestion.confidence > 0.6 ? '#ffc107' : '#dc3545';

            html += `
            <div style="margin-bottom: 8px; padding: 8px; border: 1px solid ${confidenceColor}; border-radius: 4px; font-size: 0.85em;">
                <strong>${suggestion.from_table}.${suggestion.from_column}</strong> →
                <strong>${suggestion.to_table}.${suggestion.to_column}</strong>
                <div style="margin-top: 4px; color: #666; font-size: 0.8em;">
                    ${suggestion.reason}
                </div>
                <div style="margin-top: 4px;">
                    <span style="background: ${confidenceColor}; color: white; padding: 1px 4px; border-radius: 2px; font-size: 0.7em;">
                        ${Math.round(suggestion.confidence * 100)}% confidence
                    </span>
                </div>
            </div>
        `;
        });

        if (suggestions.length > 5) {
            html += `<div style="color: #666; font-size: 0.8em;">Showing top 5 of ${suggestions.length} suggestions</div>`;
        }

        container.innerHTML = html;
    }

    function generateJoinQuery() {
        const edges = enhancedGraphData.graph.edges;
        if (edges.length === 0) return 'No relationships found to generate JOIN query';

        const edge = edges[0]; // Use first relationship
        const sourceTable = edge.source.name || edge.source.id || edge.source;
        const targetTable = edge.target.name || edge.target.id || edge.target;
        const fromColumn = edge.from_column || 'id';
        const toColumn = edge.to_column || 'id';

        return `-- Example JOIN query based on relationships
SELECT
    t1.*,
    t2.*
FROM \`${sourceTable}\` t1
INNER JOIN \`${targetTable}\` t2
    ON t1.\`${fromColumn}\` = t2.\`${toColumn}\`
LIMIT 100;`;
    }

    function generateAggregateQuery() {
        const nodes = enhancedGraphData.graph.nodes;
        if (!nodes || nodes.length === 0) {
            return '-- No tables available for aggregate query';
        }

        // Find the largest table by row count
        const largestTable = nodes.reduce((max, node) => {
            const maxRows = max.row_count || max.rows || 0;
            const nodeRows = node.row_count || node.rows || 0;
            return nodeRows > maxRows ? node : max;
        });

        const tableName = largestTable.name || largestTable.id;
        const rowCount = largestTable.row_count || largestTable.rows || 0;

        return `-- Aggregate analysis for largest table: ${tableName}
-- Table has ${rowCount > 0 ? rowCount.toLocaleString() + ' rows' : 'unknown row count'}
SELECT
    COUNT(*) as total_records,
    COUNT(DISTINCT *) as unique_records
FROM \`${tableName}\`;

-- Add your specific aggregate columns here
-- Example:
-- SELECT column_name, COUNT(*) as count
-- FROM \`${tableName}\`
-- GROUP BY column_name
-- ORDER BY count DESC;`;
    }

    function generateIntegrityQuery() {
        return `-- Database integrity checks
PRAGMA integrity_check;
PRAGMA foreign_key_check;

-- Check for orphaned records in relationships
-- (Replace with actual table/column names)`;
    }

    function generateOptimizationSuggestions() {
        const nodes = enhancedGraphData.graph.nodes;
        const largeTablesWithoutIndexes = nodes.filter(n => n.row_count > 1000 && n.foreign_key_count > 0);

        if (largeTablesWithoutIndexes.length === 0) {
            return '-- No immediate optimization suggestions\n-- Your database schema looks well-optimized!';
        }

        return `-- Optimization suggestions based on schema analysis
-- Consider adding indexes to these large tables:
${largeTablesWithoutIndexes.map(t => `-- CREATE INDEX idx_${t.name}_fk ON \`${t.name}\` (foreign_key_column);`).join('\n')}

-- Run ANALYZE to update statistics:
ANALYZE;

-- Consider VACUUM if database has grown significantly:
-- VACUUM;`;
    }

    function displayQueryTemplates(templates) {
        const modal = createModal('📋 Smart Query Templates', `
        <div style="max-height: 70vh; overflow-y: auto;">
            <p style="margin-bottom: 20px; color: #666;">Smart query templates based on your database schema:</p>
            ${Object.entries(templates).map(([category, queries]) => `
                <div style="margin-bottom: 25px;">
                    <h4 style="color: #667eea; margin-bottom: 15px; text-transform: capitalize; border-bottom: 2px solid #667eea; padding-bottom: 8px;">
                        ${category.replace('_', ' ')} Queries
                    </h4>
                    ${queries.slice(0, 4).map(query => createTemplateCard(query)).join('')}
                </div>
            `).join('')}
        </div>
    `);
        document.body.appendChild(modal);
    }

    function createTemplateCard(template) {
        return `
        <div style="margin-bottom: 15px; padding: 15px; border: 1px solid #e9ecef; border-radius: 8px; background: #f8f9fa; transition: all 0.2s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            <div style="margin-bottom: 8px;">
                <strong style="color: #333; font-size: 1em;">${template.name}</strong>
                <span style="margin-left: 10px; padding: 3px 8px; background: #667eea; color: white; border-radius: 4px; font-size: 0.75em;">
                    ${template.category || 'General'}
                </span>
            </div>
            <div style="margin-bottom: 12px; color: #666; font-size: 0.9em; line-height: 1.4;">
                ${template.description}
            </div>
            <div style="font-family: 'Courier New', monospace; font-size: 0.8em; background: white; padding: 12px; border-radius: 6px; border: 1px solid #ddd; max-height: 120px; overflow-y: auto; margin-bottom: 12px; line-height: 1.3;">
                ${template.sql}
            </div>
            <div style="display: flex; gap: 8px;">
                <button onclick="copyToClipboard(\`${template.sql.replace(/`/g, '\\`')}\`); showMessage('Query copied!', 'success')"
                        style="padding: 6px 12px; font-size: 0.8em; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#218838'" onmouseout="this.style.background='#28a745'">
                    📋 Copy Query
                </button>
                <button onclick="executeTemplateQuery(\`${template.sql.replace(/`/g, '\\`')}\`)"
                        style="padding: 6px 12px; font-size: 0.8em; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#0056b3'" onmouseout="this.style.background='#007bff'">
                    ▶️ Execute
                </button>
                <button onclick="addToQueryBuilder(\`${template.sql.replace(/`/g, '\\`')}\`)"
                        style="padding: 6px 12px; font-size: 0.8em; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#138496'" onmouseout="this.style.background='#17a2b8'">
                    📝 Edit
                </button>
            </div>
        </div>
    `;
    }


    function displayFallbackTemplates() {
        const fallbackTemplates = {
            basic_queries: [
                {
                    name: "Database Schema Overview",
                    description: "Get comprehensive information about all tables and their structure",
                    sql: `-- Database Schema Overview
SELECT
    name as table_name,
    type,
    sql as create_statement
FROM sqlite_master
WHERE type IN ('table', 'view')
    AND name NOT LIKE 'sqlite_%'
ORDER BY type, name;`,
                    category: "Schema"
                },
                {
                    name: "Table Row Counts",
                    description: "Get row counts for all tables to understand data distribution",
                    sql: `-- Table Row Counts
-- Note: Replace with actual table names from your database
SELECT 'Replace this with actual table names' as note;

-- Example for common table patterns:
-- SELECT 'users' as table_name, COUNT(*) as row_count FROM users
-- UNION ALL
-- SELECT 'orders' as table_name, COUNT(*) as row_count FROM orders;`,
                    category: "Analysis"
                },
                {
                    name: "Foreign Key Relationships",
                    description: "Show all foreign key constraints in the database",
                    sql: `-- Foreign Key Relationships
SELECT
    m.name as table_name,
    p.seq as fk_sequence,
    p."table" as referenced_table,
    p."from" as from_column,
    p."to" as to_column
FROM sqlite_master m
JOIN pragma_foreign_key_list(m.name) p
WHERE m.type = 'table'
ORDER BY m.name, p.seq;`,
                    category: "Relationships"
                },
                {
                    name: "Table Indexes",
                    description: "List all indexes and their associated tables",
                    sql: `-- Table Indexes
SELECT
    m.name as index_name,
    m.tbl_name as table_name,
    m.sql as index_definition
FROM sqlite_master m
WHERE m.type = 'index'
    AND m.name NOT LIKE 'sqlite_%'
ORDER BY m.tbl_name, m.name;`,
                    category: "Performance"
                }
            ],
            data_analysis: [
                {
                    name: "Data Quality Check",
                    description: "Check for common data quality issues",
                    sql: `-- Data Quality Checks
-- Replace 'table_name' and 'column_name' with actual values

-- Check for NULL values
-- SELECT
--     COUNT(*) as total_rows,
--     COUNT(column_name) as non_null_values,
--     COUNT(*) - COUNT(column_name) as null_values,
--     ROUND((COUNT(*) - COUNT(column_name)) * 100.0 / COUNT(*), 2) as null_percentage
-- FROM table_name;

SELECT 'Replace with actual table and column names' as instruction;`,
                    category: "Quality"
                },
                {
                    name: "Duplicate Records Check",
                    description: "Find duplicate records in a table",
                    sql: `-- Duplicate Records Check
-- Replace 'table_name' and 'key_columns' with actual values

-- SELECT
--     key_column1,
--     key_column2,
--     COUNT(*) as duplicate_count
-- FROM table_name
-- GROUP BY key_column1, key_column2
-- HAVING COUNT(*) > 1
-- ORDER BY duplicate_count DESC;

SELECT 'Replace with actual table and key column names' as instruction;`,
                    category: "Quality"
                }
            ],
            performance: [
                {
                    name: "Database Statistics",
                    description: "Get database size and performance statistics",
                    sql: `-- Database Statistics
SELECT
    (SELECT COUNT(*) FROM sqlite_master WHERE type='table') as total_tables,
    (SELECT COUNT(*) FROM sqlite_master WHERE type='index') as total_indexes,
    (SELECT COUNT(*) FROM sqlite_master WHERE type='view') as total_views;`,
                    category: "Performance"
                },
                {
                    name: "Table Size Analysis",
                    description: "Analyze table sizes and page usage",
                    sql: `-- Table Size Analysis
-- This requires the table names to be known
-- PRAGMA table_info(table_name); -- Shows column information
-- PRAGMA index_list(table_name);  -- Shows indexes for a table

SELECT 'Use PRAGMA commands with actual table names' as instruction;`,
                    category: "Performance"
                }
            ]
        };

        displayQueryTemplates(fallbackTemplates);
    }

    // Enhanced modal creation utility
    function createModal(title, content) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        padding: 20px;
    `;

        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        max-width: 90%;
        max-height: 90%;
        overflow: hidden;
        width: 800px;
        display: flex;
        flex-direction: column;
    `;

        modalContent.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px 25px; border-bottom: 1px solid #e9ecef; background: #f8f9fa;">
            <h3 style="margin: 0; color: #333; font-size: 1.1em;">${title}</h3>
            <button onclick="this.closest('.modal').remove()" style="
                background: none; border: none; font-size: 24px; cursor: pointer;
                color: #999; width: 30px; height: 30px; display: flex; align-items: center;
                justify-content: center; border-radius: 50%; transition: all 0.2s ease;
            " onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='none'">×</button>
        </div>
        <div style="padding: 25px; overflow-y: auto; flex: 1;">
            ${content}
        </div>
        <div style="padding: 15px 25px; border-top: 1px solid #e9ecef; background: #f8f9fa; text-align: center;">
            <button onclick="this.closest('.modal').remove()" style="
                padding: 10px 25px; background: #667eea; color: white; border: none;
                border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 500;
                transition: all 0.2s ease;
            " onmouseover="this.style.background='#5a67d8'" onmouseout="this.style.background='#667eea'">
                Close
            </button>
        </div>
    `;

        modal.appendChild(modalContent);

        // Close on outside click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });

        // Close on Escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                modal.remove();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);

        return modal;
    }

    // REPLACE the enrichNodeDataWithSchema function with this enhanced version
    // Enhanced enrichment for all database objects
    async function enrichNodeDataWithSchema(nodes) {
        try {
            console.log('🔍 Enriching node data with detailed database object structure...');

            // Get all database objects
            const allObjects = await getAllDatabaseObjects();
            console.log('📊 Found database objects:', allObjects.length);

            // Categorize objects
            const objectsByName = {};
            allObjects.forEach(obj => {
                if (!objectsByName[obj.name]) {
                    objectsByName[obj.name] = {
                        name: obj.name,
                        type: obj.type,
                        parent_table: obj.parent_table,
                        sql: obj.sql,
                        related_objects: []
                    };
                }
            });

            // Add related objects (indexes and triggers for tables)
            allObjects.forEach(obj => {
                if ((obj.type === 'index' || obj.type === 'trigger') && obj.parent_table) {
                    if (objectsByName[obj.parent_table]) {
                        objectsByName[obj.parent_table].related_objects.push({
                            name: obj.name,
                            type: obj.type,
                            sql: obj.sql
                        });
                    }
                }
            });

            // Enrich existing nodes and add new ones for views, indexes, triggers
            const enrichmentPromises = Object.values(objectsByName).map(async (dbObject) => {
                // Find existing node or create new one
                let node = nodes.find(n => (n.name || n.id) === dbObject.name);

                if (!node && dbObject.type !== 'table') {
                    // Create new node for views, indexes, triggers
                    node = {
                        id: dbObject.name,
                        name: dbObject.name,
                        category: getObjectCategory(dbObject.type),
                        type: dbObject.type,
                        parent_table: dbObject.parent_table,
                        sql_definition: dbObject.sql,
                        related_objects: dbObject.related_objects || [],
                        column_count: 0,
                        columns: 0,
                        foreign_key_count: 0,
                        foreign_keys: 0,
                        importance: calculateObjectImportance(dbObject),
                        row_count: 0,
                        rows: 0
                    };
                    nodes.push(node);
                    console.log(`✅ Added new ${dbObject.type} node: ${dbObject.name}`);
                } else if (node) {
                    // Enrich existing table node
                    node.type = dbObject.type;
                    node.related_objects = dbObject.related_objects || [];
                    node.sql_definition = dbObject.sql;

                    // Get detailed structure for tables and views
                    if (dbObject.type === 'table' || dbObject.type === 'view') {
                        try {
                            const response = await fetch(`/api/table/${dbObject.name}/structure`);
                            const result = await response.json();

                            if (result.success && result.structure) {
                                const structure = result.structure;

                                if (structure.columns) {
                                    node.column_count = structure.columns.length;
                                    node.columns = structure.columns.length;
                                }

                                if (structure.foreign_keys && Array.isArray(structure.foreign_keys)) {
                                    node.foreign_key_count = structure.foreign_keys.length;
                                    node.foreign_keys = structure.foreign_keys.length;
                                }

                                if (structure.indexes && Array.isArray(structure.indexes)) {
                                    node.index_count = structure.indexes.length;
                                }

                                console.log(`✅ Enriched ${dbObject.type} ${dbObject.name}:`, {
                                    columns: node.column_count,
                                    foreign_keys: node.foreign_key_count,
                                    related_objects: node.related_objects.length
                                });
                            }
                        } catch (error) {
                            console.warn(`⚠️ Could not get structure for ${dbObject.name}:`, error);
                        }
                    }
                }
            });

            await Promise.all(enrichmentPromises);
            console.log('🎉 All database objects enriched. Total nodes:', nodes.length);

        } catch (error) {
            console.error('⚠️ Error in enrichNodeDataWithSchema:', error);
        }
    }

    // Enhanced query results display
    function displayQueryResults(result) {
        const modal = createModal(`📊 Query Results (${result.row_count || 0} rows)`, `
        <div style="max-height: 70vh; overflow: auto;">
            ${result.data && result.data.length > 0 ? `
                <div style="margin-bottom: 15px;">
                    <div style="background: linear-gradient(135deg, #28a745, #20c997); color: white; padding: 12px; border-radius: 8px; text-align: center;">
                        <strong>✅ Query executed successfully!</strong><br>
                        <span style="font-size: 0.9em; opacity: 0.9;">
                            Showing ${Math.min(result.data.length, 50)} of ${result.row_count || result.data.length} total rows
                        </span>
                    </div>
                </div>

                <div style="overflow-x: auto; border-radius: 8px; border: 1px solid #e9ecef;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">
                                ${result.columns.map(col =>
            `<th style="border: 1px solid rgba(255,255,255,0.2); padding: 12px 8px; text-align: left; font-weight: 500; position: sticky; top: 0;">${col}</th>`
        ).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${result.data.slice(0, 50).map((row, index) => `
                                <tr style="background: ${index % 2 === 0 ? '#f8f9fa' : 'white'}; transition: background-color 0.2s ease;" onmouseover="this.style.background='#e3f2fd'" onmouseout="this.style.background='${index % 2 === 0 ? '#f8f9fa' : 'white'}'">
                                    ${result.columns.map(col => {
            const value = row[col];
            let displayValue = value === null ? '<em style="color: #999; font-style: italic;">NULL</em>' :
                value === '' ? '<em style="color: #999; font-style: italic;">empty</em>' :
                    String(value);

            // Truncate long values
            if (displayValue.length > 100) {
                displayValue = displayValue.substring(0, 100) + '...';
            }

            return `<td style="border: 1px solid #dee2e6; padding: 8px; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${value}">${displayValue}</td>`;
        }).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>

                ${result.data.length > 50 ? `
                    <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 6px; text-align: center; border-left: 4px solid #ffc107;">
                        <strong>⚠️ Results truncated</strong><br>
                        <span style="font-size: 0.9em;">Showing first 50 rows only. Total: ${result.data.length} rows</span>
                    </div>
                ` : ''}

                <div style="margin-top: 15px; text-align: center;">
                    <button onclick="exportQueryResults(${JSON.stringify(result).replace(/"/g, '&quot;')})"
                            style="padding: 8px 16px; background: #17a2b8; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px; transition: all 0.2s ease;" onmouseover="this.style.background='#138496'" onmouseout="this.style.background='#17a2b8'">
                        💾 Export Results
                    </button>
                </div>
            ` : `
                <div style="text-align: center; padding: 40px; color: #666;">
                    <div style="font-size: 3em; margin-bottom: 15px; opacity: 0.5;">📄</div>
                    <h4 style="margin-bottom: 10px;">No Results</h4>
                    <p style="margin: 0; font-size: 0.9em;">The query executed successfully but returned no data.</p>
                    <div style="margin-top: 20px; padding: 15px; background: #d1ecf1; border-radius: 8px; text-align: left;">
                        <strong>💡 This could mean:</strong>
                        <ul style="margin: 10px 0; padding-left: 20px; font-size: 0.9em;">
                            <li>The table is empty</li>
                            <li>The WHERE conditions filtered out all rows</li>
                            <li>The table/column names in the query don't exist</li>
                        </ul>
                    </div>
                </div>
            `}
        </div>
    `);
        document.body.appendChild(modal);
    }

    function convertToCSV(result) {
        if (!result.data || result.data.length === 0) {
            return 'No data to export';
        }

        // Create CSV header
        const header = result.columns.join(',');

        // Create CSV rows
        const rows = result.data.map(row => {
            return result.columns.map(col => {
                const value = row[col];
                // Escape CSV special characters
                if (value === null) return '';
                const stringValue = String(value);
                if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                    return `"${stringValue.replace(/"/g, '""')}"`;
                }
                return stringValue;
            }).join(',');
        });

        return [header, ...rows].join('\n');
    }

    // Helper function to export query results
    window.exportQueryResults = function (result) {
        try {
            const csv = convertToCSV(result);
            const filename = `query_results_${new Date().toISOString().split('T')[0]}.csv`;
            downloadFile(csv, filename);
            showMessage('Results exported as CSV', 'success');
        } catch (error) {
            showMessage('Export error: ' + error.message, 'error');
        }
    };


    // Helper function to add query to query builder
    window.addToQueryBuilder = function (sql) {
        // Switch to analysis tab
        switchTab('analysis');
        document.querySelector('[onclick="switchTab(\'analysis\')"]').classList.add('active');

        // Add to query output
        document.getElementById('generatedQuery').innerHTML = `<pre><code>${sql}</code></pre>`;
        document.getElementById('generatedQuery').style.display = 'block';

        // Close any open modals
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => modal.remove());

        showMessage('Query added to builder for editing', 'success');
    };
    // Enhanced template query execution with better error handling
    window.executeTemplateQuery = async function (sql) {
        try {
            showLoading(true, 'Executing template query...');

            const response = await fetch('/api/execute-query', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({query: sql})
            });

            const result = await response.json();

            if (result.success) {
                displayQueryResults(result);
                showMessage(`Query executed successfully. ${result.row_count || 0} rows returned.`, 'success');
            } else {
                showMessage('Query failed: ' + result.error, 'error');

                // Show error details in modal
                const errorModal = createModal('❌ Query Execution Error', `
                <div style="text-align: center;">
                    <div style="font-size: 3em; margin-bottom: 15px; color: #dc3545;">❌</div>
                    <h3 style="color: #dc3545; margin-bottom: 20px;">Query Failed</h3>

                    <div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: left;">
                        <strong>Error Details:</strong><br>
                        <code style="font-size: 0.9em; color: #721c24;">${result.error}</code>
                    </div>

                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: left;">
                        <strong>Query:</strong><br>
                        <pre style="font-size: 0.8em; margin: 8px 0; overflow-x: auto;"><code>${sql}</code></pre>
                    </div>

                    <p style="margin-top: 20px; color: #666; font-size: 0.9em;">
                        This might be because the query contains placeholder table/column names that need to be replaced with actual values from your database.
                    </p>
                </div>
            `);
                document.body.appendChild(errorModal);
            }
        } catch (error) {
            showMessage('Query execution error: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };


    // Layout mode setter (now connected to dropdown)
    window.setLayoutMode = function (mode) {
        currentLayout = mode;
        document.getElementById('layoutSelect').value = mode;

        if (!enhancedGraphData) return;

        const {nodes, edges} = enhancedGraphData.graph;
        const width = enhancedSvg.attr('width');
        const height = enhancedSvg.attr('height');

        // CRITICAL: Clear all fixed positions before switching layouts
        nodes.forEach(node => {
            node.fx = null;
            node.fy = null;
        });

        // Stop current simulation
        if (enhancedSimulation) {
            enhancedSimulation.stop();
        }

        // Small delay to ensure the simulation stops completely
        setTimeout(() => {
            switch (mode) {
                case 'force':
                    applyForceLayout(nodes, edges, width, height);
                    break;
                case 'hierarchical':
                    applyHierarchicalLayout(nodes, edges, width, height);
                    break;
                case 'circular':
                    applyCircularLayout(nodes, edges, width, height);
                    break;
                case 'matrix':
                    applyMatrixLayout(nodes, edges, width, height);
                    break;
            }
        }, 100);
    };

    // Apply force layout (Replace existing function)
    window.applyForceLayout = function (nodes, edges, width, height) {
        // Clear any fixed positions for force layout
        nodes.forEach(node => {
            node.fx = null;
            node.fy = null;
        });

        enhancedSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(edges).id(d => d.id).distance(120).strength(0.8))
            .force('charge', d3.forceManyBody().strength(-600))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => getEnhancedNodeRadius(d) + 20))
            .alpha(1) // Reset alpha to restart simulation properly
            .alphaTarget(0)
            .alphaDecay(0.028); // Slower decay for better settling

        enhancedSimulation.on('tick', updateGraphPositions);

        // Restart the simulation
        enhancedSimulation.restart();

        console.log('✅ Force layout applied');
    };

    // Apply hierarchical layout (Replace existing function)
    window.applyHierarchicalLayout = function (nodes, edges, width, height) {
        console.log('🏗️ Applying hierarchical layout...');

        // Clear any existing fixed positions first
        nodes.forEach(node => {
            node.fx = null;
            node.fy = null;
        });

        // Create hierarchy based on foreign key relationships
        const levels = {};
        const visited = new Set();

        // Find root nodes (tables with no incoming foreign keys)
        const incomingFKs = new Set();
        edges.forEach(edge => {
            const targetId = edge.target.id || edge.target.name || edge.target;
            incomingFKs.add(targetId);
        });

        const rootNodes = nodes.filter(node => {
            const nodeId = node.id || node.name;
            return !incomingFKs.has(nodeId);
        });

        // If no clear roots, use all nodes as roots
        const startNodes = rootNodes.length > 0 ? rootNodes : [nodes[0]];

        // BFS to assign levels
        const queue = startNodes.map(node => ({node, level: 0}));

        while (queue.length > 0) {
            const {node, level} = queue.shift();
            const nodeId = node.id || node.name;

            if (visited.has(nodeId)) continue;
            visited.add(nodeId);

            if (!levels[level]) levels[level] = [];
            levels[level].push(node);

            // Find children
            edges.forEach(edge => {
                const sourceId = edge.source.id || edge.source.name || edge.source;
                const targetId = edge.target.id || edge.target.name || edge.target;

                if (sourceId === nodeId && !visited.has(targetId)) {
                    const targetNode = nodes.find(n => (n.id || n.name) === targetId);
                    if (targetNode) {
                        queue.push({node: targetNode, level: level + 1});
                    }
                }
            });
        }

        // Add any remaining unvisited nodes to the last level
        const unvisited = nodes.filter(node => !visited.has(node.id || node.name));
        if (unvisited.length > 0) {
            const maxLevel = Math.max(...Object.keys(levels).map(Number));
            const lastLevel = maxLevel + 1;
            if (!levels[lastLevel]) levels[lastLevel] = [];
            levels[lastLevel].push(...unvisited);
        }

        // Position nodes
        const levelCount = Object.keys(levels).length;
        const levelHeight = height / (levelCount + 1);

        Object.entries(levels).forEach(([level, levelNodes]) => {
            const y = (parseInt(level) + 1) * levelHeight;
            const nodeWidth = width / (levelNodes.length + 1);

            levelNodes.forEach((node, index) => {
                node.x = (index + 1) * nodeWidth;
                node.y = y;
                // Set fixed positions for hierarchical layout
                node.fx = node.x;
                node.fy = node.y;
            });
        });

        // Create simulation with minimal forces to maintain positions
        enhancedSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(edges).id(d => d.id).distance(150).strength(0.1))
            .alpha(0.3)
            .alphaTarget(0)
            .alphaDecay(0.05);

        enhancedSimulation.on('tick', updateGraphPositions);

        console.log('✅ Hierarchical layout applied with', levelCount, 'levels');
    };

    // Apply circular layout (Replace existing function)
    window.applyCircularLayout = function (nodes, edges, width, height) {
        console.log('⭕ Applying circular layout...');

        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.35;

        nodes.forEach((node, index) => {
            const angle = (2 * Math.PI * index) / nodes.length;
            node.x = centerX + radius * Math.cos(angle);
            node.y = centerY + radius * Math.sin(angle);
            // Set fixed positions for circular layout
            node.fx = node.x;
            node.fy = node.y;
        });

        enhancedSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(edges).id(d => d.id).distance(120).strength(0.2))
            .alpha(0.3)
            .alphaTarget(0)
            .alphaDecay(0.05);

        enhancedSimulation.on('tick', updateGraphPositions);

        console.log('✅ Circular layout applied');
    };

    // Apply matrix layout (Replace existing function)
    window.applyMatrixLayout = function (nodes, edges, width, height) {
        console.log('📊 Applying matrix layout...');

        const cols = Math.ceil(Math.sqrt(nodes.length));
        const rows = Math.ceil(nodes.length / cols);

        const cellWidth = width / cols;
        const cellHeight = height / rows;
        const padding = 50; // Add some padding

        nodes.forEach((node, index) => {
            const row = Math.floor(index / cols);
            const col = index % cols;

            node.x = col * cellWidth + cellWidth / 2 + (Math.random() - 0.5) * 20; // Small random offset
            node.y = row * cellHeight + cellHeight / 2 + (Math.random() - 0.5) * 20;
            // Set fixed positions for matrix layout
            node.fx = node.x;
            node.fy = node.y;
        });

        enhancedSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(edges).id(d => d.id).distance(100).strength(0.1))
            .alpha(0.3)
            .alphaTarget(0)
            .alphaDecay(0.05);

        enhancedSimulation.on('tick', updateGraphPositions);

        console.log('✅ Matrix layout applied');
    };

    // Update graph positions (Replace existing function)
    // Control functions
    window.updateNodeSizing = function () {
        if (!enhancedGraphData) return;

        // Update node radius
        enhancedSvg.selectAll('.node')
            .transition()
            .duration(300)
            .attr('r', getEnhancedNodeRadius);

        // Update activity rings
        enhancedSvg.selectAll('.node-activity-ring')
            .transition()
            .duration(300)
            .attr('r', d => getEnhancedNodeRadius(d) + 12);

        // Update label font size to match node size
        enhancedSvg.selectAll('.node-label')
            .transition()
            .duration(300)
            .style('font-size', d => `${Math.max(12, getEnhancedNodeRadius(d) * 0.3)}px`);
    };

    // Update graph positions (Replace existing function)
    window.updateGraphPositions = function () {
        // Update links
        enhancedSvg.selectAll('.link')
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        // Update node containers (this moves both circles and labels together)
        enhancedSvg.selectAll('.node-container')
            .attr('transform', d => `translate(${d.x},${d.y})`);

        // Update activity rings
        enhancedSvg.selectAll('.node-activity-ring')
            .style('display', d => d.activity > 0.1 ? 'block' : 'none')
            .attr('r', d => getEnhancedNodeRadius(d) + 12 + (d.activity * 20));

        // Update link labels
        enhancedSvg.selectAll('.link-label')
            .attr('x', d => getLinkLabelX(d))
            .attr('y', d => getLinkLabelY(d));
    };

    // Add this new function to reset layouts completely
    window.resetLayout = function () {
        if (!enhancedGraphData) return;

        console.log('🔄 Resetting layout completely...');

        const {nodes, edges} = enhancedGraphData.graph;

        // Clear all fixed positions
        nodes.forEach(node => {
            node.fx = null;
            node.fy = null;
            node.x = undefined;
            node.y = undefined;
            node.vx = 0;
            node.vy = 0;
        });

        // Stop current simulation
        if (enhancedSimulation) {
            enhancedSimulation.stop();
        }

        // Re-render the graph completely
        setTimeout(() => {
            renderEnhancedGraph(enhancedGraphData.graph);
            showMessage('Layout reset successfully', 'success');
        }, 100);
    };


    // Enhanced control functions
    window.zoomToFit = function () {
        if (!enhancedSvg || !enhancedGraphData) return;

        const bounds = enhancedSvg.select('.graph-group').node().getBBox();
        const fullWidth = enhancedSvg.attr('width');
        const fullHeight = enhancedSvg.attr('height');
        const width = bounds.width;
        const height = bounds.height;

        if (width === 0 || height === 0) return;

        const scale = 0.8 / Math.max(width / fullWidth, height / fullHeight);
        const translate = [fullWidth / 2 - scale * (bounds.x + width / 2), fullHeight / 2 - scale * (bounds.y + height / 2)];

        enhancedSvg.transition().duration(750).call(
            d3.zoom().transform,
            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
        );
    };


    // Enhanced utility functions
    window.populateEnhancedTableSelectors = function (nodes) {
        const fromSelect = document.getElementById('pathFromTable');
        const toSelect = document.getElementById('pathToTable');

        fromSelect.innerHTML = '<option value="">Select table...</option>';
        toSelect.innerHTML = '<option value="">Select table...</option>';

        nodes.forEach(node => {
            const tableName = node.name || node.id;
            const rowCount = node.row_count || node.rows || 0;
            const displayText = rowCount > 0 ? `${tableName} (${rowCount} rows)` : tableName;

            fromSelect.innerHTML += `<option value="${tableName}">${displayText}</option>`;
            toSelect.innerHTML += `<option value="${tableName}">${displayText}</option>`;
        });
    };

    // Enhanced relationship suggestions
    window.updateRelationshipSuggestions = function (suggestions) {
        // This function is called during initial load - we can integrate with displayRelationshipSuggestions
        if (suggestions && suggestions.length > 0) {
            displayRelationshipSuggestions(suggestions);
        }
    };

    // Control functions
    window.updateNodeSizing = function () {
        if (!enhancedGraphData) return;

        // Update node radius
        enhancedSvg.selectAll('.node')
            .transition()
            .duration(300)
            .attr('r', getEnhancedNodeRadius);

        // Update activity rings
        enhancedSvg.selectAll('.node-activity-ring')
            .transition()
            .duration(300)
            .attr('r', d => getEnhancedNodeRadius(d) + 12);

        // Update label font size to match node size
        enhancedSvg.selectAll('.node-label')
            .transition()
            .duration(300)
            .style('font-size', d => `${Math.max(12, getEnhancedNodeRadius(d) * 0.3)}px`);
    };

    window.updateEdgeLabels = function () {
        const mode = document.getElementById('edgeLabelMode').value;

        enhancedSvg.selectAll('.link-label')
            .style('display', mode === 'none' ? 'none' : 'block')
            .text(d => getLinkLabelText(d));
    };

    window.filterByCategory = function () {
        const category = document.getElementById('categoryFilter').value;

        if (!enhancedGraphData) return;

        if (category === 'all') {
            enhancedSvg.selectAll('.node').style('opacity', 1);
            enhancedSvg.selectAll('.link').style('opacity', 0.6);
        } else {
            enhancedSvg.selectAll('.node')
                .style('opacity', d => d.category === category ? 1 : 0.2);

            enhancedSvg.selectAll('.link')
                .style('opacity', d =>
                    (d.source.category === category || d.target.category === category) ? 0.8 : 0.1
                );
        }
    };


    window.toggleAnimation = function () {
        animationEnabled = !animationEnabled;

        if (enhancedSimulation) {
            if (animationEnabled) {
                enhancedSimulation.restart();
            } else {
                enhancedSimulation.stop();
            }
        }

        showMessage(animationEnabled ? 'Animation enabled' : 'Animation paused', 'info');
    };

    window.exportDiagram = async function (format = 'json') {
        try {
            showLoading(true, `Exporting as ${format.toUpperCase()}...`);

            const response = await fetch('/api/schema/export-relationship-diagram', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({format})
            });

            const result = await response.json();

            if (result.success) {
                const content = result.export_data.content || JSON.stringify(result.export_data, null, 2);
                const filename = `relationship_diagram_${new Date().toISOString().split('T')[0]}.${format}`;
                downloadFile(content, filename);
                showMessage(`${format.toUpperCase()} export downloaded`, 'success');
            } else {
                showMessage('Export failed: ' + result.error, 'error');
            }
        } catch (error) {
            showMessage('Export error: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };

    window.showFullScreen = function () {
        const container = document.querySelector('.graph-container');
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        }
    };

    // Enhanced refresh function
    window.refreshRelationshipData = async function () {
        try {
            showLoading(true, 'Refreshing relationship data...');

            // Clear existing data
            enhancedGraphData = null;
            relationshipMetrics = null;

            // Reload all data
            await loadEnhancedRelationshipData();

            showMessage('✅ Relationship data refreshed successfully', 'success');
        } catch (error) {
            showMessage('❌ Error refreshing data: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };

    // Analysis and action functions
    window.generateJoinFromNode = function (nodeName) {
        if (!enhancedGraphData || !enhancedGraphData.graph) {
            showMessage('No graph data available', 'warning');
            return;
        }

        const outgoingEdges = enhancedGraphData.graph.edges.filter(e =>
            e.source === nodeName || e.source.id === nodeName || e.source.name === nodeName
        );

        if (outgoingEdges.length === 0) {
            showMessage(`No relationships found for table ${nodeName}`, 'warning');
            return;
        }

        const edge = outgoingEdges[0];
        const targetTable = edge.target.name || edge.target;

        const joinQuery = `SELECT t1.*, t2.*
                           FROM \`${nodeName}\` t1
                                    INNER JOIN \`${targetTable}\` t2 ON t1.\`${edge.from_column}\` = t2.\`${edge.to_column}\` LIMIT 100;`;

        copyToClipboard(joinQuery);
        showMessage('JOIN query generated and copied to clipboard!', 'success');
    };

    window.analyzeNodePerformance = function (nodeName) {
        if (!enhancedGraphData || !enhancedGraphData.graph) {
            showMessage('No graph data available', 'warning');
            return;
        }

        const node = enhancedGraphData.graph.nodes.find(n => n.name === nodeName || n.id === nodeName);
        if (!node) {
            showMessage(`Table ${nodeName} not found`, 'error');
            return;
        }

        const connectedEdges = enhancedGraphData.graph.edges.filter(edge =>
            edge.source === nodeName || edge.target === nodeName ||
            edge.source.id === nodeName || edge.target.id === nodeName ||
            edge.source.name === nodeName || edge.target.name === nodeName
        );

        const avgStrength = connectedEdges.length > 0 ?
            connectedEdges.reduce((sum, edge) => sum + (edge.strength || 0.5), 0) / connectedEdges.length : 0;

        // Safe access to properties with fallbacks
        const rowCount = node.row_count || node.rows || 0;
        const columnCount = node.column_count || node.columns || 0;

        // ✅ FIXED: Use both possible property names for foreign keys, with edge-based fallback
        let foreignKeyCount = node.foreign_key_count || node.foreign_keys || 0;

        // If foreign key count is still 0 but we have outgoing relationships, use relationship count
        const outgoingRels = connectedEdges.filter(edge =>
            edge.source === nodeName || edge.source.id === nodeName || edge.source.name === nodeName
        );
        if (foreignKeyCount === 0 && outgoingRels.length > 0) {
            foreignKeyCount = outgoingRels.length;
        }

        const importance = node.importance || 0;
        const category = node.category || node.type || 'Unknown';

        const analysis = `
Performance Analysis for ${nodeName}:
• Table Size: ${rowCount > 0 ? rowCount.toLocaleString() + ' rows' : 'Size unknown'}
• Columns: ${columnCount > 0 ? columnCount : 'Unknown'}
• Foreign Keys: ${foreignKeyCount} ${foreignKeyCount !== (node.foreign_key_count || node.foreign_keys || 0) ? '(calculated from relationships)' : ''}
• Relationships: ${connectedEdges.length}
• Average Relationship Strength: ${(avgStrength * 100).toFixed(1)}%
• Category: ${category}
• Importance Score: ${importance > 0 ? importance.toLocaleString() : 'Not calculated'}

Recommendations:
${rowCount > 10000 ? '• Consider indexing for large table performance\n' : ''}
${connectedEdges.length > 3 ? '• High connectivity - ensure proper indexing\n' : ''}
${avgStrength < 0.5 ? '• Weak relationships detected - review data quality\n' : ''}
${connectedEdges.length === 0 ? '• No relationships found - consider adding foreign keys\n' : ''}
${rowCount === 0 ? '• Table size unknown - ensure proper schema analysis\n' : ''}
${foreignKeyCount === 0 && connectedEdges.length > 0 ? '• Table has relationships but no foreign key constraints defined\n' : ''}
${foreignKeyCount > 0 ? '• Table properly defines foreign key relationships\n' : ''}
    `;

        // Create a better modal for the analysis
        const modal = createModal('📊 Performance Analysis', `
        <div style="font-family: 'Courier New', monospace; white-space: pre-wrap; background: #f8f9fa; padding: 20px; border-radius: 8px; line-height: 1.6; font-size: 0.9em;">
            ${analysis}
        </div>
        <div style="margin-top: 20px; text-align: center;">
            <button onclick="copyToClipboard(\`${analysis.replace(/`/g, '\\`')}\`); showMessage('Analysis copied to clipboard!', 'success')"
                    style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; margin-right: 10px;">
                📋 Copy Analysis
            </button>
        </div>
    `);
        document.body.appendChild(modal);
    };

    window.generateJoinFromLink = function (sourceTable, targetTable, fromColumn, toColumn) {
        const joinQuery = `SELECT t1.*, t2.*
                           FROM \`${sourceTable}\` t1
                                    INNER JOIN \`${targetTable}\` t2 ON t1.\`${fromColumn}\` = t2.\`${toColumn}\` LIMIT 100;`;

        copyToClipboard(joinQuery);
        showMessage('JOIN query generated and copied to clipboard!', 'success');
    };

    window.analyzeRelationshipPerformance = function (sourceTable, targetTable) {
        if (!enhancedGraphData || !enhancedGraphData.graph) {
            showMessage('No graph data available', 'warning');
            return;
        }

        const edge = enhancedGraphData.graph.edges.find(e =>
            (e.source === sourceTable && e.target === targetTable) ||
            (e.source === targetTable && e.target === sourceTable) ||
            (e.source.name === sourceTable && e.target.name === targetTable) ||
            (e.source.name === targetTable && e.target.name === sourceTable)
        );

        if (!edge) {
            showMessage('Relationship not found', 'error');
            return;
        }

        const analysis = `
Relationship Performance Analysis:
${sourceTable} ↔ ${targetTable}

• Relationship Type: ${getCardinalityDescription(edge.relationship_type)}
• Strength Score: ${((edge.strength || 0.5) * 100).toFixed(1)}%
• Performance Impact: ${getPerformanceImpact(edge)}
• Join Condition: ${edge.from_column} = ${edge.to_column}

Optimization Tips:
${(edge.strength || 0.5) < 0.5 ? '• Low strength - consider data cleanup\n' : ''}
• Add index on ${edge.from_column} if not present
• Consider query optimization for this relationship
• Monitor JOIN performance in queries
    `;

        alert(analysis);
    };

    // Smart query generation
    window.generateSmartQuery = function () {
        const queryType = document.getElementById('queryType').value;

        if (!enhancedGraphData || !enhancedGraphData.graph.nodes.length) {
            showMessage('No database schema loaded', 'warning');
            return;
        }

        let query = '';

        switch (queryType) {
            case 'join':
                query = generateJoinQuery();
                break;
            case 'aggregate':
                query = generateAggregateQuery();
                break;
            case 'integrity':
                query = generateIntegrityQuery();
                break;
            case 'optimization':
                query = generateOptimizationSuggestions();
                break;
        }

        if (query) {
            document.getElementById('generatedQuery').innerHTML = `<pre><code>${query}</code></pre>`;
            document.getElementById('generatedQuery').style.display = 'block';
        }
    };

    window.updateQueryBuilder = function () {
        // Update query builder based on selected type
        generateSmartQuery();
    };

    // Advanced analysis functions
    window.runIntegrityAnalysis = async function () {
        try {
            showLoading(true, 'Running relationship integrity analysis...');

            const response = await fetch('/api/schema/relationship-analysis');
            const result = await response.json();

            if (result.success) {
                updateAnalysisInsights(result.analysis, result.summary);
                showMessage('Integrity analysis completed', 'success');
            } else {
                showMessage('Analysis failed: ' + result.error, 'error');
            }
        } catch (error) {
            showMessage('Analysis error: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };

    window.suggestOptimizations = async function () {
        try {
            showLoading(true, 'Generating optimization suggestions...');

            const response = await fetch('/api/schema/optimize-suggestions');
            const result = await response.json();

            if (result.success) {
                displayOptimizationSuggestions(result.suggestions);
            } else {
                showMessage('Failed to get suggestions: ' + result.error, 'error');
            }
        } catch (error) {
            showMessage('Error getting suggestions: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };


    window.generateEnhancedReport = async function () {
        try {
            showLoading(true, 'Generating comprehensive relationship report...');

            // Gather all data for the report
            const [graphData, analysisData, metricsData] = await Promise.all([
                fetch('/api/schema/relationship-graph').then(r => r.json()).catch(() => ({success: false})),
                fetch('/api/schema/relationship-analysis').then(r => r.json()).catch(() => ({success: false})),
                fetch('/api/schema/relationship-metrics').then(r => r.json()).catch(() => ({success: false}))
            ]);

            const report = {
                timestamp: new Date().toISOString(),
                database_name: 'Current Database',
                summary: {
                    total_tables: graphData.success ? graphData.graph.nodes.length : 0,
                    total_relationships: graphData.success ? graphData.graph.edges.length : 0,
                    health_score: metricsData.success ? metricsData.overall_health_score : 0
                },
                graph_data: graphData.success ? graphData.graph : null,
                analysis: analysisData.success ? analysisData.analysis : null,
                metrics: metricsData.success ? metricsData.metrics : null
            };

            downloadFile(JSON.stringify(report, null, 2), `relationship_report_${new Date().toISOString().split('T')[0]}.json`);
            showMessage('Enhanced report generated and downloaded', 'success');

        } catch (error) {
            showMessage('Error generating report: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };

    // Export functions
    window.exportAsJSON = function () {
        if (!enhancedGraphData) {
            showMessage('No data to export', 'warning');
            return;
        }

        const data = {
            nodes: enhancedGraphData.graph.nodes,
            edges: enhancedGraphData.graph.edges,
            metrics: enhancedGraphData.graph.metrics,
            exported_at: new Date().toISOString(),
            format: 'json'
        };

        downloadFile(JSON.stringify(data, null, 2), 'relationships.json');
        showMessage('JSON export downloaded', 'success');
    };

    window.exportAsGraphML = function () {
        exportDiagram('graphml');
    };

    window.exportAsCytoscape = function () {
        exportDiagram('cytoscape');
    };

    window.exportAsDOT = function () {
        exportDiagram('dot');
    };

    // Placeholder functions for additional features
    window.generateQueryTemplates = async function () {
        try {
            showLoading(true, 'Generating smart query templates...');

            const response = await fetch('/api/schema/query-templates');
            const result = await response.json();

            if (result.success) {
                displayQueryTemplates(result.templates);
                showMessage('Query templates generated successfully', 'success');
            } else {
                showMessage('Failed to generate templates: ' + (result.error || 'Unknown error'), 'error');
            }
        } catch (error) {
            console.error('Error generating templates:', error);
            showMessage('Error generating templates: ' + error.message, 'error');

            // Show fallback templates if API fails
            displayFallbackTemplates();
        } finally {
            showLoading(false);
        }
    };


    window.showSchemaStatistics = async function () {
        showMessage('Schema statistics feature - would load from /api/schema/statistics', 'info');
    };

    window.runVacuum = async function () {
        showMessage('VACUUM operation - would call /api/schema/maintenance/vacuum', 'info');
    };

    window.runAnalyze = async function () {
        showMessage('ANALYZE operation - would call /api/schema/maintenance/analyze', 'info');
    };

    window.loadRelationshipSuggestions = async function () {
        showMessage('Loading relationship suggestions...', 'info');

        // Switch to analysis tab to show suggestions
        switchTab('analysis');
        document.querySelector('[onclick="switchTab(\'analysis\')"]').classList.add('active');

        try {
            const response = await fetch('/api/schema/relationship-suggestions');
            const result = await response.json();

            if (result.success) {
                displayRelationshipSuggestions(result.suggestions);
            } else {
                showMessage('No suggestions available', 'info');
            }
        } catch (error) {
            showMessage('Error loading suggestions: ' + error.message, 'error');
        }
    };

    // DEBUGGING: Add this function to test the API endpoint directly
    window.testTableStructureAPI = async function (tableName) {
        try {
            console.log(`🧪 Testing /api/table/${tableName}/structure`);

            const response = await fetch(`/api/table/${tableName}/structure`);
            const result = await response.json();

            console.log('📊 Structure API Response:', result);

            if (result.success && result.structure && result.structure.columns) {
                console.log(`✅ Table ${tableName} has ${result.structure.columns.length} columns:`, result.structure.columns.map(c => c.name));
                return result.structure.columns.length;
            } else {
                console.log(`❌ Structure API failed for ${tableName}:`, result);
                return 0;
            }
        } catch (error) {
            console.error(`❌ Error testing structure API for ${tableName}:`, error);
            return 0;
        }
    };

    // DEBUGGING: Add this function to test all your tables
    window.testAllTableStructures = async function () {
        if (!enhancedGraphData || !enhancedGraphData.graph || !enhancedGraphData.graph.nodes) {
            console.log('❌ No graph data available');
            return;
        }

        console.log('🧪 Testing table structure API for all tables...');

        for (const node of enhancedGraphData.graph.nodes) {
            const tableName = node.name || node.id;
            const columnCount = await testTableStructureAPI(tableName);
            console.log(`Table ${tableName}: ${columnCount} columns (was: ${node.column_count || node.columns || 'unknown'})`);
        }
    };

    // ADD this debugging function to test foreign key detection:
    window.debugForeignKeys = async function (tableName) {
        if (!tableName && enhancedGraphData && enhancedGraphData.graph && enhancedGraphData.graph.nodes.length > 0) {
            tableName = enhancedGraphData.graph.nodes[0].name;
        }

        if (!tableName) {
            console.log('❌ No table name provided and no graph data available');
            return;
        }

        console.log(`🔍 Debugging foreign keys for table: ${tableName}`);

        try {
            const response = await fetch(`/api/table/${tableName}/structure`);
            const result = await response.json();

            console.log('📊 Full structure response:', result);

            if (result.success && result.structure) {
                console.log('🔑 Foreign keys in structure:', result.structure.foreign_keys);
                console.log('📋 Columns in structure:', result.structure.columns?.length || 0);
                console.log('🗝️ Primary keys in structure:', result.structure.primary_keys);
                console.log('📇 Indexes in structure:', result.structure.indexes?.length || 0);
            }

            // Also check the node data
            if (enhancedGraphData && enhancedGraphData.graph) {
                const node = enhancedGraphData.graph.nodes.find(n => n.name === tableName);
                if (node) {
                    console.log('🎯 Current node data:', {
                        foreign_key_count: node.foreign_key_count,
                        foreign_keys: node.foreign_keys,
                        column_count: node.column_count,
                        columns: node.columns
                    });
                }
            }

        } catch (error) {
            console.error('❌ Error debugging foreign keys:', error);
        }
    };

    // Helper function to show table schema
    window.showTableSchema = async function(tableName) {
        try {
            showLoading(true, `Loading schema for ${tableName}...`);

            const response = await fetch(`/api/table/${tableName}/structure`);
            const result = await response.json();

            if (result.success && result.structure) {
                const structure = result.structure;

                const modal = createModal(`📋 Schema: ${tableName}`, `
                <div style="max-height: 70vh; overflow-y: auto;">
                    <h4>Columns</h4>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                            <thead>
                                <tr style="background: #f8f9fa;">
                                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: left;">Name</th>
                                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: left;">Type</th>
                                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: left;">Nullable</th>
                                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: left;">Default</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${structure.columns?.map(col => `
                                    <tr>
                                        <td style="border: 1px solid #dee2e6; padding: 8px; font-weight: 500;">${col.name}</td>
                                        <td style="border: 1px solid #dee2e6; padding: 8px; font-family: monospace;">${col.type}</td>
                                        <td style="border: 1px solid #dee2e6; padding: 8px;">${col.notnull ? 'No' : 'Yes'}</td>
                                        <td style="border: 1px solid #dee2e6; padding: 8px; font-family: monospace;">${col.dflt_value || 'NULL'}</td>
                                    </tr>
                                `).join('') || '<tr><td colspan="4" style="text-align: center; padding: 20px; color: #666;">No columns found</td></tr>'}
                            </tbody>
                        </table>
                    </div>

                    ${structure.foreign_keys?.length > 0 ? `
                        <h4>Foreign Keys</h4>
                        <ul style="margin-bottom: 20px;">
                            ${structure.foreign_keys.map(fk => `
                                <li style="margin-bottom: 5px;">
                                    <strong>${fk.from}</strong> → <strong>${fk.table}.${fk.to}</strong>
                                </li>
                            `).join('')}
                        </ul>
                    ` : ''}

                    ${structure.indexes?.length > 0 ? `
                        <h4>Indexes</h4>
                        <ul>
                            ${structure.indexes.map(idx => `
                                <li style="margin-bottom: 5px;">
                                    <strong>${idx.name}</strong> ${idx.unique ? '(UNIQUE)' : ''}
                                </li>
                            `).join('')}
                        </ul>
                    ` : ''}
                </div>
            `);

                document.body.appendChild(modal);
            } else {
                showMessage('Could not load schema information', 'error');
            }
        } catch (error) {
            showMessage('Error loading schema: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };

    // Helper function to generate relationship report
    // Enhanced relationship report generator
    window.generateRelationshipReport = async function(tableName) {
        try {
            showLoading(true, `Generating comprehensive report for ${tableName}...`);

            if (!enhancedGraphData || !enhancedGraphData.graph) {
                showMessage('No graph data available', 'error');
                return;
            }

            const { nodes, edges } = enhancedGraphData.graph;

            // Find the target node
            const targetNode = nodes.find(n => (n.name || n.id) === tableName);
            if (!targetNode) {
                showMessage(`Table ${tableName} not found`, 'error');
                return;
            }

            // Collect comprehensive data
            const reportData = await generateComprehensiveReportData(targetNode, nodes, edges);

            // Create detailed report modal
            const modal = createModal(`📑 Comprehensive Report: ${tableName}`, `
            <div style="max-height: 80vh; overflow-y: auto; padding: 10px;">
                ${generateReportHTML(reportData)}
            </div>
        `);

            document.body.appendChild(modal);

        } catch (error) {
            showMessage('Error generating report: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    };

    // Generate comprehensive report data
    async function generateComprehensiveReportData(targetNode, nodes, edges) {
        const tableName = targetNode.name || targetNode.id;

        // Basic information
        const basicInfo = {
            name: tableName,
            type: targetNode.type || 'table',
            category: targetNode.category || 'Unknown',
            rowCount: targetNode.row_count || targetNode.rows || 0,
            columnCount: targetNode.column_count || targetNode.columns || 0,
            foreignKeyCount: targetNode.foreign_key_count || targetNode.foreign_keys || 0,
            importance: targetNode.importance || 0
        };

        // Relationship analysis
        const outgoingRels = edges.filter(e => e.source.id === targetNode.id || e.source.name === tableName);
        const incomingRels = edges.filter(e => e.target.id === targetNode.id || e.target.name === tableName);

        const relationships = {
            outgoing: outgoingRels,
            incoming: incomingRels,
            total: outgoingRels.length + incomingRels.length,
            avgStrength: calculateAverageStrength([...outgoingRels, ...incomingRels]),
            strongConnections: [...outgoingRels, ...incomingRels].filter(rel => (rel.strength || 0.5) > 0.7),
            weakConnections: [...outgoingRels, ...incomingRels].filter(rel => (rel.strength || 0.5) < 0.3)
        };

        // Performance metrics
        const performance = {
            connectivityScore: relationships.total > 0 ? Math.min(100, relationships.total * 10) : 0,
            dataIntegrity: relationships.avgStrength * 100,
            optimizationLevel: calculateOptimizationLevel(targetNode, relationships),
            indexUtilization: targetNode.index_count || 0
        };

        // Get detailed schema information
        let schemaDetails = null;
        try {
            const response = await fetch(`/api/table/${tableName}/structure`);
            const result = await response.json();
            if (result.success) {
                schemaDetails = result.structure;
            }
        } catch (error) {
            console.warn('Could not fetch schema details:', error);
        }

        // Connected nodes analysis
        const connectedNodes = getConnectedNodesDetailed(targetNode, nodes, edges);

        // Path analysis
        const pathAnalysis = await analyzeNodePaths(targetNode, nodes, edges);

        // Generate recommendations
        const recommendations = generateNodeRecommendations(targetNode, relationships, performance, schemaDetails);

        return {
            basicInfo,
            relationships,
            performance,
            schemaDetails,
            connectedNodes,
            pathAnalysis,
            recommendations,
            generatedAt: new Date().toISOString()
        };
    }

    // Calculate average relationship strength
    function calculateAverageStrength(relationships) {
        if (relationships.length === 0) return 0;
        const totalStrength = relationships.reduce((sum, rel) => sum + (rel.strength || 0.5), 0);
        return totalStrength / relationships.length;
    }

    // Calculate optimization level
    function calculateOptimizationLevel(node, relationships) {
        let score = 50; // Base score

        // Add points for good practices
        if (node.index_count > 0) score += 20;
        if (relationships.avgStrength > 0.7) score += 15;
        if (node.foreign_key_count > 0) score += 10;
        if (relationships.weakConnections.length === 0) score += 5;

        // Subtract points for issues
        if (relationships.weakConnections.length > 2) score -= 15;
        if (node.row_count > 100000 && node.index_count === 0) score -= 20;
        if (relationships.total === 0) score -= 10;

        return Math.max(0, Math.min(100, score));
    }

    // Get detailed connected nodes
    function getConnectedNodesDetailed(targetNode, nodes, edges) {
        const connected = [];
        const tableName = targetNode.name || targetNode.id;

        edges.forEach(edge => {
            const sourceName = edge.source.name || edge.source.id || edge.source;
            const targetName = edge.target.name || edge.target.id || edge.target;

            if (sourceName === tableName) {
                const connectedNode = nodes.find(n => (n.name || n.id) === targetName);
                if (connectedNode) {
                    connected.push({
                        node: connectedNode,
                        relationship: edge,
                        direction: 'outgoing'
                    });
                }
            } else if (targetName === tableName) {
                const connectedNode = nodes.find(n => (n.name || n.id) === sourceName);
                if (connectedNode) {
                    connected.push({
                        node: connectedNode,
                        relationship: edge,
                        direction: 'incoming'
                    });
                }
            }
        });

        return connected;
    }

    // Analyze paths from this node
    async function analyzeNodePaths(targetNode, nodes, edges) {
        const tableName = targetNode.name || targetNode.id;
        const pathAnalysis = {
            shortestPaths: [],
            longestPath: 0,
            reachableNodes: 0,
            centralityScore: 0
        };

        try {
            // Build adjacency list for path analysis
            const adjacencyList = {};
            nodes.forEach(node => {
                adjacencyList[node.name || node.id] = new Set();
            });

            edges.forEach(edge => {
                const sourceName = edge.source.name || edge.source.id || edge.source;
                const targetName = edge.target.name || edge.target.id || edge.target;
                adjacencyList[sourceName].add(targetName);
                adjacencyList[targetName].add(sourceName);
            });

            // Find paths to other important nodes
            const importantNodes = nodes.filter(n => n.importance > 500 && n.name !== tableName);

            for (const node of importantNodes.slice(0, 5)) { // Limit to top 5
                const path = findShortestPath(adjacencyList, tableName, node.name);
                if (path && path.length > 1) {
                    pathAnalysis.shortestPaths.push({
                        target: node.name,
                        path: path,
                        hops: path.length - 1
                    });
                    pathAnalysis.longestPath = Math.max(pathAnalysis.longestPath, path.length - 1);
                }
            }

            pathAnalysis.reachableNodes = adjacencyList[tableName].size;
            pathAnalysis.centralityScore = Math.min(100, pathAnalysis.reachableNodes * 5);

        } catch (error) {
            console.warn('Error in path analysis:', error);
        }

        return pathAnalysis;
    }

    // Generate optimization recommendations
    function generateNodeRecommendations(node, relationships, performance, schemaDetails) {
        const recommendations = [];

        // Performance recommendations
        if (node.row_count > 50000 && node.index_count === 0) {
            recommendations.push({
                type: 'performance',
                priority: 'high',
                title: 'Add Indexes for Large Table',
                description: `Table has ${node.row_count.toLocaleString()} rows but no indexes. Consider adding indexes on frequently queried columns.`,
                action: `CREATE INDEX idx_${node.name}_primary ON \`${node.name}\` (id);`
            });
        }

        // Relationship recommendations
        if (relationships.weakConnections.length > 0) {
            recommendations.push({
                type: 'data_quality',
                priority: 'medium',
                title: 'Improve Weak Relationships',
                description: `${relationships.weakConnections.length} relationships have low strength scores. Review data quality and foreign key constraints.`,
                action: 'Review and clean data inconsistencies'
            });
        }

        // Schema recommendations
        if (schemaDetails && schemaDetails.foreign_keys.length === 0 && relationships.outgoing.length > 0) {
            recommendations.push({
                type: 'schema',
                priority: 'medium',
                title: 'Add Foreign Key Constraints',
                description: 'Table has relationships but no formal foreign key constraints defined.',
                action: 'Add proper foreign key constraints to enforce referential integrity'
            });
        }

        // Isolation recommendations
        if (relationships.total === 0) {
            recommendations.push({
                type: 'architecture',
                priority: 'low',
                title: 'Isolated Table',
                description: 'Table has no relationships with other tables. Consider if this is intentional.',
                action: 'Review if relationships should be established with other tables'
            });
        }

        // Optimization recommendations
        if (performance.optimizationLevel < 70) {
            recommendations.push({
                type: 'optimization',
                priority: 'medium',
                title: 'General Optimization Needed',
                description: `Optimization score is ${performance.optimizationLevel}/100. Multiple improvements possible.`,
                action: 'Review indexing strategy, relationship quality, and query patterns'
            });
        }

        return recommendations;
    }

    // Generate HTML for the comprehensive report
    function generateReportHTML(data) {
        const { basicInfo, relationships, performance, schemaDetails, connectedNodes, pathAnalysis, recommendations } = data;

        return `
        <!-- Executive Summary -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h2 style="margin: 0 0 10px 0; font-size: 1.5em;">${getServiceIcon(basicInfo.category)} ${basicInfo.name}</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 15px;">
                <div style="text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold;">${basicInfo.rowCount.toLocaleString()}</div>
                    <div style="opacity: 0.9; font-size: 0.9em;">Rows</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold;">${basicInfo.columnCount}</div>
                    <div style="opacity: 0.9; font-size: 0.9em;">Columns</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold;">${relationships.total}</div>
                    <div style="opacity: 0.9; font-size: 0.9em;">Relationships</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 1.8em; font-weight: bold;">${performance.optimizationLevel}%</div>
                    <div style="opacity: 0.9; font-size: 0.9em;">Optimization</div>
                </div>
            </div>
        </div>

        <!-- Performance Metrics -->
        <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
            <h3 style="color: #2d3748; margin-bottom: 15px; display: flex; align-items: center;">
                📊 Performance Metrics
            </h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div style="background: #f7fafc; padding: 15px; border-radius: 6px;">
                    <div style="font-size: 1.3em; font-weight: bold; color: ${performance.connectivityScore > 70 ? '#48bb78' : performance.connectivityScore > 40 ? '#ed8936' : '#e53e3e'};">
                        ${performance.connectivityScore}/100
                    </div>
                    <div style="color: #718096; font-size: 0.9em;">Connectivity Score</div>
                </div>
                <div style="background: #f7fafc; padding: 15px; border-radius: 6px;">
                    <div style="font-size: 1.3em; font-weight: bold; color: ${performance.dataIntegrity > 70 ? '#48bb78' : performance.dataIntegrity > 40 ? '#ed8936' : '#e53e3e'};">
                        ${performance.dataIntegrity.toFixed(1)}%
                    </div>
                    <div style="color: #718096; font-size: 0.9em;">Data Integrity</div>
                </div>
            </div>
        </div>

        <!-- Relationship Details -->
        <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
            <h3 style="color: #2d3748; margin-bottom: 15px;">🔗 Relationship Analysis</h3>

            ${relationships.outgoing.length > 0 ? `
                <h4 style="color: #667eea; margin-bottom: 10px;">Outgoing References (${relationships.outgoing.length})</h4>
                <div style="margin-bottom: 15px;">
                    ${relationships.outgoing.map(rel => `
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 8px; border-left: 3px solid #667eea;">
                            <div style="font-weight: 500;">${rel.target.name || rel.target.id} <span style="background: #e2e8f0; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 8px;">${((rel.strength || 0.5) * 100).toFixed(0)}%</span></div>
                            <div style="font-size: 0.85em; color: #718096; margin-top: 4px;">
                                ${rel.from_column} → ${rel.to_column} (${getCardinalityDescription(rel.relationship_type)})
                            </div>
                        </div>
                    `).join('')}
                </div>
            ` : ''}

            ${relationships.incoming.length > 0 ? `
                <h4 style="color: #48bb78; margin-bottom: 10px;">Incoming References (${relationships.incoming.length})</h4>
                <div style="margin-bottom: 15px;">
                    ${relationships.incoming.map(rel => `
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 8px; border-left: 3px solid #48bb78;">
                            <div style="font-weight: 500;">${rel.source.name || rel.source.id} <span style="background: #e2e8f0; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; margin-left: 8px;">${((rel.strength || 0.5) * 100).toFixed(0)}%</span></div>
                            <div style="font-size: 0.85em; color: #718096; margin-top: 4px;">
                                ${rel.from_column} → ${rel.to_column} (${getCardinalityDescription(rel.relationship_type)})
                            </div>
                        </div>
                    `).join('')}
                </div>
            ` : ''}
        </div>

        <!-- Schema Information -->
        ${schemaDetails ? `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <h3 style="color: #2d3748; margin-bottom: 15px;">📋 Schema Details</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                        <thead>
                            <tr style="background: #f7fafc;">
                                <th style="border: 1px solid #e2e8f0; padding: 8px; text-align: left;">Column</th>
                                <th style="border: 1px solid #e2e8f0; padding: 8px; text-align: left;">Type</th>
                                <th style="border: 1px solid #e2e8f0; padding: 8px; text-align: left;">Nullable</th>
                                <th style="border: 1px solid #e2e8f0; padding: 8px; text-align: left;">Default</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${schemaDetails.columns?.map(col => `
                                <tr>
                                    <td style="border: 1px solid #e2e8f0; padding: 8px; font-weight: 500;">${col.name}</td>
                                    <td style="border: 1px solid #e2e8f0; padding: 8px; font-family: monospace; color: #667eea;">${col.type}</td>
                                    <td style="border: 1px solid #e2e8f0; padding: 8px;">${col.notnull ? 'No' : 'Yes'}</td>
                                    <td style="border: 1px solid #e2e8f0; padding: 8px; font-family: monospace;">${col.dflt_value || 'NULL'}</td>
                                </tr>
                            `).join('') || '<tr><td colspan="4" style="text-align: center; padding: 20px; color: #a0aec0;">No schema information available</td></tr>'}
                        </tbody>
                    </table>
                </div>
            </div>
        ` : ''}

        <!-- Recommendations -->
        ${recommendations.length > 0 ? `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid #e2e8f0;">
                <h3 style="color: #2d3748; margin-bottom: 15px;">💡 Optimization Recommendations</h3>
                ${recommendations.map(rec => {
            const priorityColors = {
                high: '#e53e3e',
                medium: '#ed8936',
                low: '#48bb78'
            };
            return `
                        <div style="border: 1px solid #e2e8f0; border-radius: 6px; padding: 15px; margin-bottom: 10px; border-left: 4px solid ${priorityColors[rec.priority]};">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                <h4 style="margin: 0; color: #2d3748; font-size: 1em;">${rec.title}</h4>
                                <span style="background: ${priorityColors[rec.priority]}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.75em; text-transform: uppercase;">
                                    ${rec.priority}
                                </span>
                            </div>
                            <p style="color: #4a5568; margin-bottom: 10px; line-height: 1.5;">${rec.description}</p>
                            ${rec.action ? `
                                <div style="background: #f7fafc; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 0.85em; color: #2d3748;">
                                    ${rec.action}
                                </div>
                            ` : ''}
                        </div>
                    `;
        }).join('')}
            </div>
        ` : ''}

        <!-- Export Options -->
        <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
            <button onclick="exportRelationshipReport('${basicInfo.name}')"
                    style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-right: 10px; font-size: 0.9em;">
                📄 Export Report
            </button>
            <button onclick="copyReportToClipboard('${basicInfo.name}')"
                    style="background: #48bb78; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 0.9em;">
                📋 Copy to Clipboard
            </button>
        </div>
    `;
    }

    // Export relationship report
    window.exportRelationshipReport = function(tableName) {
        try {
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `${tableName}_relationship_report_${timestamp}.html`;

            // Get the report content from the modal
            const modalContent = document.querySelector('.modal div[style*="padding: 25px"]');

            if (!modalContent) {
                showMessage('Could not find report content to export', 'error');
                return;
            }

            const reportContent = modalContent.innerHTML;
            const fullHTML = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Relationship Report - ${tableName}</title>
            <meta charset="UTF-8">
            <style>
                body {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    margin: 20px;
                    background: #f8f9fa;
                    line-height: 1.6;
                }
                .container {
                    max-width: 900px;
                    margin: 0 auto;
                    background: white;
                    padding: 30px;
                    border-radius: 8px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                }
                h1, h2, h3, h4 { color: #2d3748; }
                table { width: 100%; border-collapse: collapse; margin: 10px 0; }
                th, td { border: 1px solid #e2e8f0; padding: 8px; text-align: left; }
                th { background: #f7fafc; }
                .metric-card {
                    background: #f8f9fa;
                    padding: 15px;
                    border-radius: 6px;
                    margin: 10px 0;
                    border-left: 4px solid #667eea;
                }
                @media print {
                    body { background: white; }
                    .container { box-shadow: none; }
                }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Database Relationship Report</h1>
                <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>
                <p><strong>Table:</strong> ${tableName}</p>
                <hr>
                ${reportContent}
            </div>
        </body>
        </html>
    `;

            downloadFile(fullHTML, filename);
            showMessage('Report exported successfully!', 'success');
        } catch (error) {
            console.error('Export error:', error);
            showMessage('Error exporting report: ' + error.message, 'error');
        }
    };

    // Copy report to clipboard
    window.copyReportToClipboard = function(tableName) {
        try{
            const reportElement = document.querySelector('.modal');
            if (reportElement) {
                const textContent = reportElement.innerText;
                copyToClipboard(textContent);
                showMessage('Report copied to clipboard!', 'success');
            }
        } catch (error) {
            console.error('Copy to clipboard error:', error);
            showMessage('Error copying report to clipboard: ' + error.message, 'error');
        }
    };

    console.log('🔧 Added debugForeignKeys function. Usage:');
    console.log('debugForeignKeys("tableName") - Debug foreign keys for a specific table');
    console.log('debugForeignKeys() - Debug foreign keys for the first table in graph');

</script>
</body>
</html>
